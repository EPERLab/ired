# -*- coding: utf-8 -*-
"""
/***************************************************************************
 ired
                                 A QGIS plugin
 Integración de Recursos Energéticos Distribuidos
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2020-11-13
        git sha              : $Format:%H$
        copyright            : (C) 2020 by EPERLab
        email                : eperlab.eie@ucr.ac.cr
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction
from .QGIS_run_OpenDSS_transformer import Ui_Transformer

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .ired_dialog import iredDialog
import os.path
from qgis.core import NULL
from qgis.PyQt.QtWidgets import QFileDialog, QMessageBox
import traceback
import glob
import pandas as pd
import re
import csv
from qgis.core import QgsProject
from qgis.PyQt.QtGui import QDesktopServices
from qgis.PyQt.QtCore import QUrl
import subprocess
import sys
import numpy as np
import time
import io
import copy
from qgis.core import QgsSymbol
from qgis.core import QgsLineSymbol
from qgis.core import QgsRendererRange
from qgis.core import QgsGraduatedSymbolRenderer
from PyQt5.QtGui import QColor
from qgis.utils import iface

from .Hybrid_Iterative_Functions import *
from . import auxiliary_functions as auxfcns

pd.options.mode.chained_assignment = None


class ired:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'ired_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&IRED')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.dlg = iredDialog()
        # Ventana del transformador principal
        self.transformer = Ui_Transformer()
        type_tx_conns = [QCoreApplication.translate('dialog', 'Estrella'),
                         QCoreApplication.translate('dialog', 'Delta')]
        self.transformer.comboBox_conn_high.clear()
        self.transformer.comboBox_conn_high.addItems(type_tx_conns)
        self.transformer.comboBox_conn_tertiary.clear()
        self.transformer.comboBox_conn_tertiary.addItems(type_tx_conns)
        self.transformer.comboBox_conn_low.clear()
        self.transformer.comboBox_conn_low.addItems(type_tx_conns)
        type_tx_conns = ['wye', 'delta']
        tap_location = [QCoreApplication.translate('dialog', 'Alta'),
                        QCoreApplication.translate('dialog', 'Baja')]
        self.transformer.comboBox_tap_location.clear()
        self.transformer.comboBox_tap_location.addItems(tap_location)

        # Configuracion de señales en caratula
        self.start_gui()
        self.output = ""

    """
    Función para inicializar los aspectos de la interfaz gráfica
    """
    def start_gui(self):
        self.dlg.buttonBox.helpRequested.connect(self.show_help)
        self.dlg.pushButton_output_folder.clicked.connect(self.select_output_folder)
        self.dlg.pushButton_load_curve.clicked.connect(self.select_demand_curve)
        # self.dlg.pushButton_transformer.clicked.connect(self.transformer_button)

        # Habilitación de checks de tipos de fallas ls
        self.dlg.cf_ls.toggled.connect(self.enabler_fails_ls)
        self.dlg.st_ls.toggled.connect(self.enabler_fails_ls)
        self.dlg.coord_rf_ls.toggled.connect(self.enabler_fails_ls)
        self.dlg.rr_ls.toggled.connect(self.enabler_fails_ls)

        # Habilitación de checks de tipos de fallas ss
        self.dlg.cf_ss.toggled.connect(self.enabler_fails_ss)
        self.dlg.st_ss.toggled.connect(self.enabler_fails_ss)
        self.dlg.coord_rf_ss.toggled.connect(self.enabler_fails_ss)
        self.dlg.rr_ss.toggled.connect(self.enabler_fails_ss)

        # Tab siempre iniciará en ls
        self.dlg.tabWidget.setCurrentIndex(0)

    def show_help(self):
        """Display application help to the user."""

        help_file = 'file:///%s/help/Manual_IRED.pdf' % self.plugin_dir
        # For testing path:
        # QMessageBox.information(None, 'Help File', help_file)
        # noinspection PyCallByClass,PyTypeChecker
        QDesktopServices.openUrl(QUrl(help_file))

    # Función que habilita o deshabilita los tipos de falla en ls
    def enabler_fails_ls(self):
        # Se habilitan las fallas en ls
        if (self.dlg.cf_ls.isChecked() or self.dlg.st_ls.isChecked()
                or self.dlg.coord_rf_ls.isChecked()
                or self.dlg.rr_ls.isChecked()):
            self.dlg.Box_fails_ls.setEnabled(True)
        else:
            self.dlg.Box_fails_ls.setEnabled(False)

    # Función que habilita o deshabilita los tipos de falla en ss
    def enabler_fails_ss(self):
        # Se habilitan las fallas en ls
        if (self.dlg.cf_ss.isChecked() or self.dlg.st_ss.isChecked()
                or self.dlg.coord_rf_ss.isChecked()
                or self.dlg.rr_ss.isChecked()):
            self.dlg.Box_fails_ss.setEnabled(True)
        else:
            self.dlg.Box_fails_ss.setEnabled(False)

    # Funcion para habilitar o deshabilitar estudios de fallas
    def enabler_protection_analysis(self):
        if self.protections is True:
            self.dlg.cf_ss.setEnabled(True)
            self.dlg.st_ss.setEnabled(True)
            self.dlg.rr_ss.setEnabled(True)
            self.dlg.Box_fails_ss.setEnabled(True)
            self.dlg.cf_ls.setEnabled(True)
            self.dlg.st_ls.setEnabled(True)
            self.dlg.rr_ls.setEnabled(True)
            self.dlg.Box_fails_ls.setEnabled(True)
        else:
            self.dlg.cf_ss.setEnabled(False)
            self.dlg.cf_ss.setChecked(False)
            self.dlg.st_ss.setEnabled(False)
            self.dlg.st_ss.setChecked(False)
            self.dlg.rr_ss.setEnabled(False)
            self.dlg.rr_ss.setChecked(False)
            self.dlg.Box_fails_ss.setEnabled(False)
            self.dlg.cf_ls.setEnabled(False)
            self.dlg.cf_ls.setChecked(False)
            self.dlg.st_ls.setEnabled(False)
            self.dlg.st_ls.setChecked(False)
            self.dlg.rr_ls.setEnabled(False)
            self.dlg.rr_ls.setChecked(False)
            self.dlg.Box_fails_ls.setEnabled(False)

        # La coordinacion recloser fusible sólo
        # se habilita si hay reclosers y fusibles
        if self.rec_fus is True:
            self.dlg.coord_rf_ss.setEnabled(True)
            self.dlg.coord_rf_ss.setChecked(True)
            self.dlg.coord_rf_ls.setEnabled(True)
            self.dlg.coord_rf_ls.setChecked(True)
        else:
            self.dlg.coord_rf_ss.setEnabled(False)
            self.dlg.coord_rf_ss.setChecked(False)
            self.dlg.coord_rf_ls.setEnabled(False)
            self.dlg.coord_rf_ls.setChecked(False)

    # Muestra la ventana del transformador principal
    def transformer_button(self):
        self.transformer.show()

    # fill the circuit comboBox
    def circuit_calling(self):
        try:
            self.dlg.lineEdit_circuit_name.clear()
            prjpath = QgsProject.instance().fileName()
            if not prjpath:
                msg = "El projecto en QGIS debe estar abierto para "
                msg += "poder analizar la red de distribución"
                title = "Error al leer proyecto GIS"
                QMessageBox.information(None, title, msg)
                return 0, 0, 0
            dir_general, dir_general2 = prjpath.split('/GIS', 1)
            # Folder where all network models are stored
            dir_network = dir_general + '/DSS'
            os.chdir(dir_network)
            networks = dir_general.split('/')[-1]
            self.dlg.lineEdit_circuit_name.setText(networks)
            # self.dlg.comboBox_circuit_name.addItems(networks)
            return prjpath, dir_general, dir_network
        except Exception:
            self.print_error()
            aviso = "El projecto en QGIS debe poseer el formato establecido "
            aviso += "en el manual y ya deben existir los archivos *.dss"
            title = "Error al leer información del circuito"
            QMessageBox.information(None, title, aviso)
            return 0, 0, 0

    # Method to select the output folder
    def select_output_folder(self):
        msg = "Seleccione carpeta de salida"
        msg_tr = QCoreApplication.translate('dialog', msg)
        output_folder = QFileDialog.getExistingDirectory(self.dlg, msg_tr, "",)
        self.dlg.lineEdit_dirOutput.setText(output_folder)

    # Method to select the load curve of the circuit
    def select_demand_curve(self):
        msg = "Seleccione el archivo .CSV para asignar curva de "
        msg += "demanda de circuito"
        msg_tr = QCoreApplication.translate('dialog', msg)
        load_curve_circuit = QFileDialog.getOpenFileName(self.dlg, msg_tr,
                                                         "", "*.csv")
        load_curve_circuit = load_curve_circuit[0]
        print("load_curve_circuit = ", str(load_curve_circuit))
        self.dlg.lineEdit_load_curve.setText(load_curve_circuit)

    """
    *******************************************************************
    *******************************************************************
    Función cktNameDefaults
    Se encarga de la lectura del archivo de salida del azul para poder
    encontrar el nombre de una capa en específico

    -Parámetros de entrada:
    *dir_general (str): directorio donde está el GIS
    *dir_network (str): directorio donde están los archivos dss


    -Valores retornados
    *voltage (int): tensión del circuito (media tensión)
    *******************************************************************
    *******************************************************************
    """

    # change the parameters according to the selected circuit
    def cktNameDefaults(self, dir_general, dir_network):
        try:
            voltage = 0
            os.chdir(dir_network)
            for file in glob.glob("*.dss"):
                file_check = re.sub('\.dss$', '', file)
                file_check = file_check[-10:]
                file_name = re.sub('\.dss$', '', file).replace('_' + file_check, '')
                if file_check == 'Substation':
                    file_name_path = str(os.getcwd()) + '\\' + '\\' + file
                    fp = open(file_name_path)
                    lines = fp.readlines()
                    line_ = lines[1]
                    line = line_.split(' ')

                    # Corriente de corto circuit subestación
                    # Monofásica
                    str_search = "isc1p="
                    in_isc1 = line_.find(str_search)
                    if in_isc1 != -1:
                        in_isc1 = line_.find("isc1p=")
                        in_isc1 += len(str_search)
                        fin_isc1 = line_.find(" ", in_isc1)
                        isc1p = line_[in_isc1:fin_isc1]
                    else:
                        isc1p = ""
                    # Trifásica
                    str_search = "isc3p="
                    in_isc3 = line_.find(str_search)
                    if in_isc3 != -1:
                        in_isc3 = line_.find("isc3p=")
                        in_isc3 += len(str_search)
                        fin_isc3 = line_.find(" ", in_isc3)
                        isc3p = line_[in_isc3:fin_isc3]
                    else:
                        isc3p = ""
                    if self.dlg.lineEdit_3pShortCircuitPower.text() == '':
                        if isc3p == "":
                            self.dlg.lineEdit_3pShortCircuitPower.setText('10')
                        else:
                            self.dlg.lineEdit_3pShortCircuitPower.setText(isc3p)

                    if self.dlg.lineEdit_1pShortCircuitPower.text() == '':
                        if isc1p == "":
                            self.dlg.lineEdit_1pShortCircuitPower.setText('10.5')
                        else:
                            self.dlg.lineEdit_1pShortCircuitPower.setText(isc1p)

                    if "UNIT" in lines[0]:  # substation is single unit
                        self.transformer.checkBox_tertiary.setCheckState(0)
                        for ij in range(len(line)):
                            line_check = line[ij]
                            # Windings fillup
                            if line_check == 'windings=3':
                                self.transformer.checkBox_tertiary.setCheckState(1)
                                # Voltages fillup
                            if line_check[:5] == 'kVs=[':
                                def_V_prim = line_check.replace('kVs=[', '')
                                voltage = def_V_prim
                                self.transformer.lineEdit_voltage_high.clear()
                                self.transformer.lineEdit_voltage_high.setText(def_V_prim)
                                V_ter = line[ij + 2]
                                if V_ter[-1:] == ']':
                                    V_sec = line[ij + 1]
                                    self.transformer.lineEdit_voltage_low.clear()
                                    self.transformer.lineEdit_voltage_low.setText(V_sec)
                                    V_ter = V_ter.replace(']', '')
                                    self.transformer.lineEdit_voltage_tertiary.clear()
                                    self.transformer.lineEdit_voltage_tertiary.setText(V_ter)
                                else:
                                    V_sec = line[ij + 1]
                                    V_sec = V_sec.replace(']', '')
                                    self.transformer.lineEdit_voltage_low.clear()
                                    self.transformer.lineEdit_voltage_low.setText(V_sec)
                            # Powers fillup
                            if line_check[:6] == 'kVAs=[':
                                P_prim = line_check.replace('kVAs=[', '')
                                self.transformer.lineEdit_power_high.clear()
                                self.transformer.lineEdit_power_high.setText(P_prim)
                                P_ter = line[ij + 2]
                                if P_ter[-1:] == ']':
                                    P_sec = line[ij + 1]
                                    self.transformer.lineEdit_power_low.clear()
                                    self.transformer.lineEdit_power_low.setText(P_sec)
                                    P_ter = P_ter.replace(']', '')
                                    self.transformer.lineEdit_power_tertiary.clear()
                                    self.transformer.lineEdit_power_tertiary.setText(P_ter)
                                else:
                                    P_sec = line[ij + 1]
                                    P_sec = P_sec.replace(']', '')
                                    self.transformer.lineEdit_power_low.clear()
                                    self.transformer.lineEdit_power_low.setText(P_sec)
                            # Reactances fillup
                            if line_check[:4] == 'xhl=':
                                X_hl = line_check.replace('xhl=', '')
                                self.transformer.lineEdit_x_hl.clear()
                                self.transformer.lineEdit_x_hl.setText(X_hl)
                            if line_check[:4] == 'xht=':
                                X_ht = line_check.replace('xht=', '')
                                self.transformer.lineEdit_x_ht.clear()
                                self.transformer.lineEdit_x_ht.setText(X_ht)
                            if line_check[:4] == 'xlt=':
                                X_lt = line_check.replace('xlt=', '')
                                self.transformer.lineEdit_x_lt.clear()
                                self.transformer.lineEdit_x_lt.setText(X_lt)
                                # Losses fillup
                            if line_check[:12] == '%noloadloss=':
                                noloadloss = line_check.replace('%noloadloss=', '')
                                self.transformer.lineEdit_losses_no_load.clear()
                                self.transformer.lineEdit_losses_no_load.setText(noloadloss)
                            if line_check[:10] == '%loadloss=':
                                inloadloss = line_check.replace('%loadloss=', '')
                                self.transformer.lineEdit_losses_in_load.clear()
                                self.transformer.lineEdit_losses_in_load.setText(inloadloss)
                            # Main bus fillup
                            if line_check[:7] == 'buses=[':
                                bus = line[ij + 1]
                                bus = bus.split('.')
                                bus = bus[0]
                                self.dlg.lineEdit_name_busbar.clear()
                                self.dlg.lineEdit_name_busbar.setText(bus)
                            # Taps fillup
                            if line_check[:8] == 'numtaps=':
                                taps = line_check.replace('numtaps=', '')
                                self.transformer.lineEdit_no_taps.setText(taps)
                            if line_check[:4] == 'tap=':
                                tap = line_check.replace('tap=', '')
                                self.transformer.lineEdit_tap_position.setText(tap)
                            if line_check[:7] == 'maxtap=':
                                maxtap = line_check.replace('maxtap=', '')
                                self.transformer.lineEdit_max_tap.setText(maxtap)
                            if line_check[:7] == 'mintap=':
                                mintap = line_check.replace('mintap=', '')
                                self.transformer.lineEdit_min_tap.setText(mintap)
                            # Connections fillup
                            if line_check[:7] == 'conns=[':
                                conP = line_check.replace('conns=[', '')
                                if conP == 'wye':
                                    self.transformer.comboBox_conn_high.setCurrentIndex(0)
                                elif conP == 'delta':
                                    self.transformer.comboBox_conn_high.setCurrentIndex(1)

                            if line_check[:7] == 'conns=[':
                                conP = line_check.replace('conns=[', '')
                                if conP == 'wye':
                                    self.transformer.comboBox_conn_high.setCurrentIndex(0)
                                elif conP == 'delta':
                                    self.transformer.comboBox_conn_high.setCurrentIndex(1)
                                conT = line[ij + 2]
                                conS = line[ij + 1]
                                if conT[-1:] == ']':
                                    if conT == 'wye]':
                                        self.transformer.comboBox_conn_tertiary.setCurrentIndex(0)
                                    elif conT == 'delta]':
                                        self.transformer.comboBox_conn_tertiary.setCurrentIndex(1)
                                    if conS == 'wye':
                                        self.transformer.comboBox_conn_low.setCurrentIndex(0)
                                    else:
                                        self.transformer.comboBox_conn_low.setCurrentIndex(1)
                                else:
                                    if conS == 'wye]':
                                        self.transformer.comboBox_conn_low.setCurrentIndex(0)
                                    elif conS == 'delta]':
                                        self.transformer.comboBox_conn_low.setCurrentIndex(1)
                            if line_check[:4] == 'wdg=':
                                if line_check == 'wdg=1':
                                    self.transformer.comboBox_tap_location.setCurrentIndex(0)
                                else:
                                    self.transformer.comboBox_tap_location.setCurrentIndex(1)
                        msg = u'Transformador principal'
                        msg_tr = QCoreApplication.translate('dialog', msg)
                    elif "NOMODEL" in lines[0]:  # substation empty model
                        voltage = line[2]
                        self.dlg.lineEdit_name_busbar.clear()
                        self.dlg.lineEdit_name_busbar.setText(line[0])
                        self.substation = 'None'
                    elif "AUTO" in lines[0]:  # substation as autotransformer
                        self.substation = 'Auto'
                        line = lines[3]
                        line_check = line.split(" ")
                        for ij in range(len(line_check)):
                            if 'kVs=[' in line_check[ij]:
                                # from kVs line to neutral to kVs line to line
                                def_V_prim = line_check[ij].replace('kVs=[', '')
                                def_V_prim = float(def_V_prim)*np.sqrt(3)
                                voltage = str(def_V_prim)
                        self.dlg.lineEdit_name_busbar.clear()
                        txt = 'BUSMV' + file_name + '1'
                        self.dlg.lineEdit_name_busbar.setText(txt)  # first bus
                        msg = u'Autotransformador en subestación'
                        msg_tr = QCoreApplication.translate('dialog', msg)
                    fp.close()
                    break
                else:
                    pass  # no substation
            return voltage
        except Exception:
            self.print_error()
            return 230

    """
    *******************************************************************
    *******************************************************************
    Función firstLine
    Se encarga de la lectura del archivo de salida del azul para poder
    encontrar el nombre de una capa en específico

    -Parámetros de entrada:
    *dir_network (str): directorio donde están los archivos dss
    *file_search (str): nombre del archivo donde se busca la primera linea

    -Valores retornados
    *line (str): nombre de la primera línea en MT
    *******************************************************************
    *******************************************************************
    """

    def firstLine(self, dir_network, file_search = 'LinesMV'):
        try:
            # line = self.dlg.lineEdit_name_busbar.text()
            mainBus = self.dlg.lineEdit_name_busbar.text() + "."
            os.chdir(dir_network)
            line = 0
            for file in glob.glob("*.dss"):
                file_check = re.sub('\.dss$', '', file)
                file_check = file_check[-7:]
                if file_check == file_search:
                    print("mainBus = ", str(mainBus))
                    file_name_path = str(os.getcwd()) + '\\' + '\\' + file
                    fp = open(file_name_path)
                    lines = fp.readlines()
                    for i in lines:
                        if mainBus in i:
                            line = i.split(" ")[1].replace('line.', '')
                            break

                    if line == '':
                        title = u"Error al encontrar primera línea"
                        msg = u"Verificar conexión de subestación"
                        QMessageBox.information(None, QCoreApplication.translate('dialog', title),
                                                QCoreApplication.translate('dialog', msg))
                    break
            return line
        except Exception:
            self.print_error()
            return 0

    """
    *******************************************************************
    *******************************************************************
    Función FindLayer
    Se encarga de la lectura del archivo de salida del azul para poder
    encontrar el nombre de una capa en específico

    -Parámetros de entrada:
    *lines (str list): lista con las líneas del archivo de salida
    del azul
    *exp_find (str): expresión que precede a los nombres de las capas.
    Por ejemplo: "Layers Transformers: "
    *gis_network (str): directorio donde está ubicado el archivo GIS

    -Valores retornados
    *list_names_layers (list): lista con los nombres de los layers
    buscados. Estará vacía si hay errores o si no existe la capa.

    *******************************************************************
    *******************************************************************
    """

    def findLayers(self, lines, exp_find, gis_network):
        try:
            list_names_layers = []
            for line in lines:
                # Búsqueda de nombres de capas
                in_exp = line.find(exp_find)
                if in_exp != -1:  # si encontró la frase anterior entra al if
                    in_exp += len(exp_find)
                    fin_exp = line.find("\n", in_exp)
                    layers_ = line[in_exp:fin_exp]
                    if layers_ != "":  # si existía la capa buscada
                        list_names_layers = layers_.split(",")
                        # se eliminan los espacios en blanco en la lista
                        list_names_layers = list(filter(None, list_names_layers))
                        # Se agrega el path de los archivos gis
                        list_names_layers = [gis_network + "/" + str(i) for i in list_names_layers]
                    break
            return list_names_layers

        except Exception:
            self.print_error()
            return 0

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('ired', message)

    def add_action(self,
                   icon_path,
                   text,
                   callback,
                   enabled_flag=True,
                   add_to_menu=True,
                   add_to_toolbar=True,
                   status_tip=None,
                   whats_this=None,
                   parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/ired/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'IRED'),
            callback=self.run,
            parent=self.iface.mainWindow())

    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&IRED'),
                action)
            self.iface.removeToolBarIcon(action)

    # Función que se encarga de imprimir los errores que han ocurrido
    def print_error(self):
        exc_info = sys.exc_info()
        msg = str(exc_info)
        msg += "\nError: " + str(exc_info)
        msg += "\n********  Información detallada del error **********"
        for tb in traceback.format_tb(sys.exc_info()[2]):
            msg += "\n" + tb

        print(msg)
        return msg

    """
    Función que se encarga de instalar una librería en
    la versión de python de QGIS
    -Parámetros de entrada:
    *library_name (string): nombre de la librería a instalar
    (tal como se le debe pasar a pip)

    -Valores retornados:
    *1 en caso de finalizar exitosamente
    *0 en caso de ocurrir algún error
    """
    def install_libraries(self, library_name):
        try:
            # Se obtiene el path de QGIS
            directorio = str(os.path)
            fin_dir = directorio.find("\\apps")
            first_letter_in = directorio.find(":\\") - 1
            first_letter = directorio[first_letter_in:first_letter_in+1]
            first_letter += ":\\"
            inic_dir = directorio.find(first_letter)
            path = directorio[inic_dir:fin_dir]
            # Se obtiene version de Python en QGIS
            info = sys.version_info
            verspy1 = str(info[0])
            verspy2 = str(info[1])
            carp_python = verspy1 + verspy2
            carp_python = "Python" + carp_python

            # Se copia los archivos
            dir_origen = path + "/bin/"
            name_file_or = "python" + verspy1 + ".dll"
            archivo_origen = str(dir_origen + name_file_or)
            dir_destino = path + "/apps/" + carp_python
            name_dest = dir_destino + "/" + name_file_or

            if os.path.exists(name_dest) is False:
                # Copia python3.dll
                self.copy(archivo_origen, dir_destino)

            # Copia python37.dll
            name_file_or = "python" + verspy1 + verspy2 + ".dll"
            archivo_origen = dir_origen + name_file_or
            name_dest = dir_destino + "/" + name_file_or

            if os.path.exists(name_dest) is False:
                # Copia python37.dll
                self.copy(archivo_origen, dir_destino)

            # Instalación de librerías
            # Actualización de pip
            sentencia = dir_origen + 'python.exe -m pip install –upgrade pip'
            subprocess.call(sentencia, cwd=dir_destino, shell=True)

            # Instalación libreria
            sentencia = dir_origen + "python.exe -m pip install " + library_name
            x = subprocess.call(sentencia, cwd=dir_destino, shell=True)
            print("x = ", x)

            print("Instalación de librería ", library_name, " finalizada.")
            return 1

        except Exception:
            self.print_error()
            return 0

    """
    Función que se encarga de instalar geopandas en QGIS
    -Parámetros de entrada:
    *library_name (string): nombre de la librería a
    instalar (tal como se le debe pasar a pip)

    -Valores retornados:
    *1 en caso de finalizar exitosamente
    *0 en caso de ocurrir algún error
    """

    def install_geopandas(self):
        try:
            # Se obtiene el path de QGIS
            directorio = str(os.path)
            fin_dir = directorio.find("\\apps")
            first_letter_in = directorio.find(":\\") - 1
            first_letter = directorio[first_letter_in:first_letter_in+1]
            first_letter += ":\\"
            inic_dir = directorio.find(first_letter)
            path = directorio[inic_dir:fin_dir]
            # Se obtiene version de Python en QGIS
            info = sys.version_info
            verspy1 = str(info[0])
            verspy2 = str(info[1])
            carp_python = verspy1 + verspy2
            carp_python = "Python" + carp_python

            # Se copian los archivos
            dir_origen = path + "/bin/"
            name_file_or = "python" + verspy1 + ".dll"
            archivo_origen = str(dir_origen + name_file_or)
            dir_destino = path + "/apps/" + carp_python
            name_dest = dir_destino + "/" + name_file_or

            if os.path.exists(name_dest) is False:
                # Copia python3.dll
                self.copy(archivo_origen, dir_destino)

            # Copia python37.dll
            name_file_or = "python" + verspy1 + verspy2 + ".dll"
            archivo_origen = dir_origen + name_file_or
            name_dest = dir_destino + "/" + name_file_or

            if os.path.exists(name_dest) is False:
                # Copia python37.dll
                self.copy(archivo_origen, dir_destino)

            # Instalación de librerías
            # Actualización de pip
            sentencia = dir_origen + 'python.exe -m pip install –upgrade pip'
            subprocess.call(sentencia, cwd=dir_destino, shell=True)

            # Instalación librerias
            sentencia = dir_origen + "python.exe -m pip install wheel"
            subprocess.call(sentencia, cwd=dir_destino, shell=True)

            sentencia = dir_origen + "python.exe -m pip install pipwin"
            subprocess.call(sentencia, cwd=dir_destino, shell=True)

            sentencia = dir_origen + "python.exe -m pipwin install numpy"
            subprocess.call(sentencia, cwd=dir_destino, shell=True)

            sentencia = dir_origen + "python.exe -m pipwin install pandas"
            subprocess.call(sentencia, cwd=dir_destino, shell=True)

            sentencia = dir_origen + "python.exe -m pipwin install shapely"
            subprocess.call(sentencia, cwd=dir_destino, shell=True)

            sentencia = dir_origen + "python.exe -m pipwin install gdal"
            subprocess.call(sentencia, cwd=dir_destino, shell=True)

            sentencia = dir_origen + "python.exe -m pipwin install fiona"
            subprocess.call(sentencia, cwd=dir_destino, shell=True)

            sentencia = dir_origen + "python.exe -m pipwin install pyproj"
            subprocess.call(sentencia, cwd=dir_destino, shell=True)

            sentencia = dir_origen + "python.exe -m pipwin install six"
            subprocess.call(sentencia, cwd=dir_destino, shell=True)

            sentencia = dir_origen + "python.exe -m pipwin install rtree"
            subprocess.call(sentencia, cwd=dir_destino, shell=True)

            sentencia = dir_origen + "python.exe -m pipwin install geopandas"
            x = subprocess.call(sentencia, cwd=dir_destino, shell=True)
            print(" x = ", x)

            print("Instalación de librería geopandas finalizada.")
            return 1

        except Exception:
            self.print_error()
            return 0

    """
    Function AttributeTable_ToDataframe
    Convert an attribute table into a dataframe
    Entries:
    *layer_name (str): layer's name

    Outputs:
    *df_at_table (dataframe): dataframe with all the information
    of the attribute table.
    """

    def AttributeTable_ToDataframe(self, layer_name):
        try:
            layer_name = layer_name.split("/")[-1]
            layer = QgsProject.instance().mapLayersByName(layer_name)[0]
            # Recibe las caracteristicas de la capa
            lineas = layer.getFeatures()
            col_names = layer.dataProvider().fields().names()
            df_att_table = pd.DataFrame(columns=col_names)
            for linea in lineas:
                attributes = linea.attributes()
                df2 = pd.DataFrame([attributes], columns=col_names)
                df2.replace(['NULL', NULL], None, inplace=True)
                df_att_table = df_att_table.append(df2,
                                                 ignore_index=True)
            df_att_table.replace(r'^\s*$', np.nan, regex=True, inplace=True)
            df_att_table.reset_index(inplace=True)
            return df_att_table, layer
        except Exception:
            self.print_error()
            return pd.DataFrame(), 0

    """
    Function save_dataframe
    Función que guarda un dataframe en capas
    Entries:
    *df (dataframe): dataframe con los datos a guardar
    *layer (QgsVectorLayer): layer donde se van a escribir los datos
    *col_new (str): nombre de la columna donde se va a guardar el
    resultado en capas. Si no se indica será aquella columna que
    exista en el dataframe y no en las capas.

    Outputs:
    *1 si finaliza exitosamente, 0 caso contrario
    """
    
    def save_dataframe(self, df, layer, col_new=""):
        try:
            lineas = layer.getFeatures()
            if col_new == "":
                col_layer = layer.dataProvider().fields().names()
                col_dataframe = list(df.columns) 
                col_new = list(set(col_dataframe) - set(col_layer))
            # print("col_dataframe = ", col_dataframe, " col_layer = ", col_layer, " col_new = ", col_new)

            layer.startEditing()
            # Se crean los nuevos atributos en el layer
            
            index_att  = auxfcns.getAttributeIndex(self, layer, col_new)
            try:
                df.reset_index(inplace=True)
            except ValueError:
                df.reset_index(inplace=True, drop=True)
            # index_att = layer.fields().indexFromName(col_new)
            for index, row in df.iterrows():
                dato = str(row[col_new])
                # print("dato = ", dato, " index_att = ", index_att, " columna = ", columna)
                layer.changeAttributeValue(index, index_att, dato)
            layer.commitChanges()
            return 1
        except Exception:
            self.print_error()
            return 0
    
    # Master.dss file creation
    def create_master(self, dir_network, name_file_created,
                      tx_active, volt_nom):
        try:
            name_circuit = name_file_created.split('_')[0]
            volt_nom = str(volt_nom)
            created_files = open(dir_network + '/' + name_file_created + '.dss', 'r')
            created_files = created_files.read()

            if tx_active is False:
                wrd1 = 'redirect ' + name_file_created.split('_')[0] + '_Substation.dss'
                created_files = created_files.replace(wrd1, '')
            
            firstLine = 'MV3P' + name_circuit + '00'
            
            file = open(dir_network + '/Master.dss', 'w')
            file.write('set defaultbasefrequency=60\n')
            # Datos de cortocircuito
            three_phase_SC = self.dlg.lineEdit_3pShortCircuitPower.text()
            if not three_phase_SC:
                three_phase_SC = 10  # def_3pSCP_nom
            single_phase_SC = self.dlg.lineEdit_1pShortCircuitPower.text()
            if not single_phase_SC:
                single_phase_SC = 10.5  # def_1pSCP_nom
            # Tensión nominal revisar

            if self.dlg.SCMVA.isChecked():  # SC MVAs
                nw_line = 'Edit Vsource.Source BasekV=' + volt_nom
                nw_line += ' pu=1.00 angle=0'
                nw_line += ' frequency=60 phases=3 MVAsc3='
                nw_line += three_phase_SC + ' MVAsc1=' + single_phase_SC + '\n'
                file.write(nw_line)
            if self.dlg.SCkA.isChecked():  # SC kAs
                nw_line = 'Edit Vsource.Source BasekV=' + volt_nom
                nw_line += ' pu=1.00 angle=0'
                nw_line += ' frequency=60 phases=3 Isc3='
                nw_line += str(float(three_phase_SC)* 1000)+ ' Isc1=' 
                nw_line += str(float(single_phase_SC)* 1000)+ '\n'
                file.write(nw_line)
            file.write(created_files + '\n')
            file.close()
            return firstLine
        except Exception:
            self.print_error()
            return ""

    """
    Function to change the column names of a dataframe: delete the 
    spaces, special characters and convert all the names to uppercase
    
    Entries:
    *df (dataframe): dataframe to convert names
    
    Output:
    *df (dataframe): dataframe with the column names converted
    """
    
    def change_columnnames(self, df):
        from unidecode import unidecode
        x = [c.upper() for c in df.columns]
        # se eliminan los espacios en los nombres de las columnas
        # en los datos reportados
        x = [c.upper() for c in x]
        x = [unidecode(c) for c in x]
        x = [c.replace(' ', '_') for c in x]
        x = [c.replace('\n', '_') for c in x]
        df.columns = x
        return df
        
    """
    Función categ_layer
    Se encarga de la categorización de una una capa tipo línea en QGIS
    Para realiza las particiones en 10 categorías distribuyéndolas entre
    el valor mínimo y máximo en la columna indicada

    Valores de entrada:
    *df (dataframe): dataframe con los datos a categorizar
    *layer (QgsVectorLayer): capa en la que se va a realizar la categorizacion
    *column_name (str): nombre de la columna que se va a categorizar

    Valores retornados:
    *1 si finaliza exitosamente, 0 si hay errores

    """

    def categ_layer(self, df, layer, column_name):
        try:
            idx_col = layer.fields().indexFromName(column_name)
            if idx_col == -1:
                msg = "No se encontró la columna " + column_name 
                msg += " por lo que no se realizara la categorización"
                print(msg)
                return 0
            max_ = df.loc[df[column_name].idxmax(), column_name]
            min_ = df.loc[df[column_name].idxmin(), column_name]
            max_ = float(max_)
            min_ = float(min_)
            datosLayer = layer.getFeatures()
            div = 6
            step = (max_- min_)/div
            
            name_cat = []
            rang_ = []
            if max_ == min_:
                msg = "El máximo y minínimo es el mismo, no se puede "
                msg += "categorizar"
                print(msg)
                return 0
            if min_ < 0:
                msg = "No deben existir valores negativos"
                print(msg)
                return 0
            
            last = min_
            while last < max_:
                sup = last + step
                name = str(round(last, 2)) + "-" + str(round(sup, 2))
                name_cat.append(name)
                rang_.append(last)
                last = sup
            
            # Último valor
            rang_.append(round(max_, 2))
            values = (
                        (name_cat[0], rang_[0], rang_[1] - 0.001, '#2e7f18', 1.6),
                        (name_cat[1], rang_[1], rang_[2] - 0.001, '#45731e', 1.6),
                        (name_cat[2], rang_[2], rang_[3] - 0.001, '#675e24', 1.6),
                        (name_cat[3], rang_[3], rang_[4] - 0.001, '#8d472b', 1.6),
                        (name_cat[4], rang_[4], rang_[5] - 0.001, '#b13433', 1.6),
                        (name_cat[5], rang_[5], rang_[6], '#c82538', 1.6),
                    )
            
            ranges = []
            
            for label, lower, upper, color, width in values:
                symbol = QgsSymbol.defaultSymbol(layer.geometryType())
                symbol.setColor(QColor(color))
                symbol = QgsLineSymbol.defaultSymbol(layer.geometryType())
                try:
                 symbol.setWidth(width)
                except:
                 aviso = "Se debe seleccionar una capa que sea del tipo línea"
                 QMessageBox.warning(None, "Error graduado de líneas", aviso)
                 return 0
                rng = QgsRendererRange(lower, upper, symbol, label)
                ranges.append(rng)
            
            GraduatedSize = QgsGraduatedSymbolRenderer.setGraduatedMethod
            renderer = QgsGraduatedSymbolRenderer(column_name, ranges)
            layer.setRenderer(renderer)    
            iface.mapCanvas().refresh() # se ejecuta un refrescado de las propiedades de la capa
            layer.triggerRepaint() #Activa los cambios inmediatamente al finalizar el plugin
            return 1
        # Caso en que sólo haya nan en el dataframe
        except KeyError:
            return 1
        except Exception:
            self.print_error()
            return 0
    
    # ##################################################################
    def run(self):
        try:
            self.protections = False
            self.rec_fus = False
            
            self.install_libraries("networkx --upgrade")
            try:
                import comtypes.client as cc
            except:
                self.install_libraries("comtypes")
                print("Instalando comtypes")
            import comtypes.client as cc
            try:
                from unidecode import unidecode
            except Exception:
                self.install_libraries("Unidecode")
                from unidecode import unidecode
            
            try:
                import geopandas as gp
                from fiona.errors import DriverError
            except Exception:
                self.install_libraries("geopandas")
                self.install_geopandas()
                import geopandas as gp
                from fiona.errors import DriverError
                print("Geopandas instalado")
            """Run method that performs all the real work"""
            # Se busca información general sobre estructura de las carpetas
            prjpath, dir_general, dir_network = self.circuit_calling()
            if prjpath == 0:
                return
            # Direcctorio de carpeta GIS
            gis_network = dir_general + "/GIS"

            # Se busca el archivo salida del azul
            name_file_created = ""
            self.dlg.lineEdit_dirOutput.clear()
            self.dlg.lineEdit_dirOutput.setText(dir_general)
            os.chdir(dir_network)

            files_names = list(glob.glob(os.path.join(dir_network, '*.dss')))
            for file in files_names:
                if len(file.split('\\')[1].split('.')[0].split('_')) > 1:
                    if file.split('\\')[1].split('.')[0].split('_')[1] == 'OutputQGIS2OpenDSS':
                        name_file_created = file.split('\\')[1].split('.')[0]

            if name_file_created == "":
                msg = "Debe existir el archivo de salida de QGIS2OpenDSS "
                msg += "para poder ejecutar el programa correctamente"
                title = "Error al encontrar salida de QGIS2OpenDSS"
                QMessageBox.information(None, title, msg)
                return None

            # Verifica si hay cargas de BT
            dir_profiles = os.path.join(dir_network,
                                        'profiles')
            self.cargas = False
            name_output_azul = dir_network + "/" + name_file_created + ".dss"
            with open(name_output_azul, "r") as f:
                lines = f.readlines()
                for line in lines:
                    linea_ = line.lower()
                    # averigua el nombre del archivo de cargas
                    if "loadslv" in linea_ and linea_[0] != "!":  
                        name_lvloads = line.replace("redirect ", "")
                        self.cargas = True
                    if "loadsmv" in linea_ and linea_[0] != "!":
                        name_mvloads = line.replace("redirect ", "")
                        self.cargas = True
            if self.cargas is True:
                load_profiles = auxfcns.ReadLoadProfiles(self, dir_profiles,
                                                         dir_network,
                                                         name_file_created)
            
            # Se buscan características del circuito en salida del azul
            volt_nom = self.cktNameDefaults(dir_general, dir_network)
            circname_azul = name_file_created.split("_")[0]

            # Valores por defecto
            phase_angle = 0
            frequency = 60

            # Se buscan los nombres de las capas
            file_ = dir_network + "/" + name_file_created + ".dss"
            with open(file_, "r") as f:
                lines = f.readlines()

            # Diccionario con las expresiones buscadas según la capa
            searched_expressions = {'Subestacion': "!Layer Substation: ",
                                    'LineasMT_sub': "Layers LinesMV_sub: ",
                                    'LineasMT_aer': "!Layers LinesMV_aer: ",
                                    'CargasMT': "!Layers LoadsMV: ",
                                    'Trafos': "!Layers Transformers: ",
                                    'LineasBT_sub': "!Layers LinesLV_sub: ",
                                    'LineasBT_aer': "!Layers LinesLV_aer: ",
                                    'Acometidas': "!Layers Acometidas: ",
                                    'CargasBT': "!Layers LoadsLV: ",
                                    'Regs': "!Layer Regulators: ",
                                    'Reclosers': "!Layer Reclosers: ",
                                    'Fuses': "!Layer Fuses: ",
                                    'Seccionadores': "!Layer Switches: ",
                                    'Capacitors': "!Layer Capacitors: ",
                                    }

            # Nombre de capa de subestación
            sub_exp = searched_expressions['Subestacion']
            layer_sub = self.findLayers(lines, sub_exp, gis_network)

            # MV Lines
            # IT'S NECESSARY TO MANTAIN THE ORIGINAL FILES IN ORDER TO UPDATE THE FILES AT THE END
            # Líneas MT aéreas
            exp_search = searched_expressions['LineasMT_aer']
            layer_mt_aer = self.findLayers(lines, exp_search, gis_network)

            # Líneas MT sub
            exp_search = searched_expressions['LineasMT_sub']
            layer_mt_sub = self.findLayers(lines, exp_search, gis_network)

            # LV lines
            vect_lv = []
            # Aéreas
            exp_search = searched_expressions['LineasBT_aer']
            layer_l_oh_lv = self.findLayers(lines, exp_search, gis_network)
            
            # Subterráneas
            exp_search = searched_expressions['LineasBT_sub']
            layer_l_ug_lv = self.findLayers(lines, exp_search, gis_network)

            # Acometidas
            exp_search = searched_expressions['Acometidas']
            layer_acom = self.findLayers(lines, exp_search, gis_network)

            # TX info
            exp_search = searched_expressions['Trafos']
            layer_tx = self.findLayers(lines, exp_search, gis_network)

            #Reguladores
            exp_search = searched_expressions['Regs']
            layer_reg = self.findLayers(lines, exp_search, gis_network)
            
            # Loads info
            # BT
            exp_search = searched_expressions['CargasBT']
            layer_load_bt = self.findLayers(lines, exp_search, gis_network)
            
            # MT
            exp_search = searched_expressions['CargasMT']
            layer_mt_loads = self.findLayers(lines, exp_search, gis_network)
            
            # Pdevice info
            # Fusibles
            exp_search = searched_expressions['Fuses']
            layer_fuses = self.findLayers(lines, exp_search, gis_network)
            
            # Reconectadores
            exp_search = searched_expressions['Reclosers']
            layer_rec = self.findLayers(lines, exp_search, gis_network)
            
            # Banderas para habilitar los estudios de protecciones
            if layer_rec != [] or layer_rec != 0 or layer_fuses != [] or layer_fuses != 0:
                self.protections = True
            if layer_rec != [] and layer_rec != 0 and layer_fuses != [] and layer_fuses != 0:
                self.rec_fus = True
            self.enabler_protection_analysis()

            # ######################################################################
            # ######################################################################
            # ######################################################################
            # ######################################################################
            # Create the dialog with elements (after translation) and keep reference
            # Only create GUI ONCE in callback, so that it will only load when the plugin is started
            # show the dialog
            self.dlg.show()
            self.msg_final = ""
            # Run the dialog event loop
            result = self.dlg.exec_()
            # See if OK was pressed
            if result:
                self.output = self.dlg.lineEdit_dirOutput.text()
                # Nombre de capa de subestación
                if layer_sub == [] or layer_sub == 0:
                    msg = "Debe existir la capa de subestación "
                    msg += "para poder ejecutar el programa correctamente"
                    title = "Error al encontrar capa"
                    QMessageBox.information(None, title, msg)
                    return None
                else:
                    try:
                        subs, sub_layer = self.AttributeTable_ToDataframe(layer_sub[0])
                        # subs = gp.read_file(layer_sub[0] + ".shp")
                    except DriverError:
                        msg = "El nombre del archivo shp de la capa de "
                        msg += "subestación debe ser igual al nombre de la capa"
                        title = "Error al encontrar capa"
                        QMessageBox.information(None, title, msg)

                # Capas de buses MV (estas siempre tendrán el mismo nombre)
                try:
                    nodes_mv, layer_mt_buses = self.AttributeTable_ToDataframe("/Bus_MT_Layer")
                    # nodes_mv = gp.read_file(gis_network + '/Bus_MT_Layer.shp')
                except DriverError:
                    msg = "Verifique que existan las capas de nodos de "
                    msg += "media tensión"
                    title = "Error al encontrar capa"
                    QMessageBox.information(None, title, msg)

                # Capas de buses LV (estas siempre tendrán el mismo nombre)
                try:
                    nodes_lv, layer_bt_buses = self.AttributeTable_ToDataframe("/Bus_BT_Layer")
                    # nodes_lv = gp.read_file(gis_network + '/Bus_BT_Layer.shp')
                    lv_groups = pd.DataFrame(list(nodes_lv['GROUP']),
                                             index=nodes_lv['BUS'],
                                             columns=['LV_GROUP'])
                except Exception:
                    nodes_lv = pd.DataFrame()
                    lv_groups = pd.DataFrame()

                # MV Lines
                # IT'S NECESSARY TO MANTAIN THE ORIGINAL FILES IN ORDER TO UPDATE THE FILES AT THE END
                # Líneas MT aéreas
                
                dist_max_mt_aer = -1
                dist_max_mt_sub = -1
                if layer_mt_aer == [] or layer_mt_aer == 0:
                    lines_mv_oh_layer_original = pd.DataFrame()
                    lines_mv_oh_layer = lines_mv_oh_layer_original.copy()
                else:
                    try:
                        lines_mv_oh_layer_original, layer_mv_oh = self.AttributeTable_ToDataframe(layer_mt_aer[0])
                        columna = "length"
                        idx_lenght = layer_mv_oh.fields().indexFromName(columna)
                        if idx_lenght == -1:
                            columna = "LENGTH"
                            idx_lenght = layer_mv_oh.fields().indexFromName(columna)
                            if idx_lenght == -1:
                                msg = "Debe introducir el atributo " + columna
                                msg += " en la capa de líneas aérea de MT"
                                title = "Error"
                                QMessageBox.information(None, title, msg)
                                return None
                        dist_max_mt_aer = float(layer_mv_oh.maximumValue(idx_lenght))
                        # lines_mv_oh_layer_original = gp.read_file(layer_mt_aer[0] + ".dbf")
                        lines_mv_oh_layer = lines_mv_oh_layer_original.copy()
                        lines_mv_oh_layer['bus2'] = lines_mv_oh_layer['bus2'].str.replace('_swt', '')
                    except DriverError:
                        lines_mv_oh_layer_original = pd.DataFrame()
                        lines_mv_oh_layer = lines_mv_oh_layer_original.copy()
                        msg = "El nombre del archivo shp de la capa de "
                        msg += "líneas MT aéreas  debe ser igual al nombre de la capa"
                        title = "Error al encontrar capa"
                        QMessageBox.information(None, title, msg)
                # Líneas MT sub
                if layer_mt_sub == [] or layer_mt_sub == 0:
                    lines_mv_ug_layer_original = pd.DataFrame()
                    lines_mv_ug_layer = lines_mv_ug_layer_original.copy()
                else:
                    try:
                        lines_mv_ug_layer_original, layer_mv_ug = self.AttributeTable_ToDataframe(layer_mt_sub[0])
                        columna = "length"
                        idx_lenght = layer_mv_ug.fields().indexFromName(columna)
                        if idx_lenght == -1:
                            columna = "LENGTH"
                            idx_lenght = layer_mv_ug.fields().indexFromName(columna)
                            if idx_lenght == -1:
                                msg = "Debe introducir el atributo " + columna
                                msg += " en la capa de líneas aérea de MT"
                                title = "Error"
                                QMessageBox.information(None, title, msg)
                                return None
                        dist_max_mt_sub = float(layer_mv_ug.maximumValue(idx_lenght))
                        # lines_mv_ug_layer_original = gp.read_file(layer_mt_sub[0] + ".dbf")
                        lines_mv_ug_layer = lines_mv_ug_layer_original.copy()
                        lines_mv_ug_layer['bus2'] = lines_mv_ug_layer['bus2'].str.replace('_swt', '')
                    except DriverError:
                        lines_mv_ug_layer_original = pd.DataFrame()
                        lines_mv_ug_layer = lines_mv_ug_layer_original.copy()
                        msg = "El nombre del archivo shp de la capa de "
                        msg += "líneas MT subterráneas debe ser igual al nombre de la capa"
                        title = "Error al encontrar capa"
                        QMessageBox.information(None, title, msg)

                if lines_mv_oh_layer_original.empty and lines_mv_ug_layer_original.empty:
                    msg = "Debe existir la capa de líneas de media tensión "
                    msg += "para poder ejecutar el programa correctamente"
                    title = "Error al encontrar capa"
                    QMessageBox.information(None, title, msg)
                    return None

                # Union capas de líneas
                lines_mv = pd.concat([lines_mv_oh_layer, lines_mv_ug_layer],
                                     sort=True)
                lines_mv.index = range(len(lines_mv.index))
                drp_ls = lines_mv.loc[lines_mv['DSSNAME'].isnull()].index.values
                lines_mv = lines_mv.loc[(lines_mv.DSSNAME != NULL), :]
                lines_mv = lines_mv.loc[(lines_mv.DSSNAME != ""), :]
                lines_mv = lines_mv.drop(drp_ls)
                lines_mv.index = range(len(lines_mv.index))
                
                # Distancia entre puntos de instalacion
                fixed_distance = self.dlg.distance_ls.value()*1000
                print("fixed_distance =", fixed_distance)
                
                """
                Distancia entre puntos de instalación
                Debe ser mayor a la distancia más larga
                """
                dist_max = max(dist_max_mt_aer, dist_max_mt_sub)
                if fixed_distance < dist_max:
                    fixed_distance = math.floor(round(dist_max, 2))
                    msg = "La distancia entre puntos de instalación seleccionada"
                    msg += " es menor a la longitud de la línea de MT con mayor longitud"
                    msg += "\nSe simulará con la longitud de la mayor "
                    msg += "línea de MT: " + str(fixed_distance)
                    title = "Error"
                    QMessageBox.information(None, title, msg)

                # LV lines
                vect_lv = []
                # Aéreas
                if layer_l_oh_lv == [] or layer_l_oh_lv == 0:
                    lines_lv_oh_layer = pd.DataFrame()
                else:
                    try:
                        lines_lv_oh_layer, layer_lv_oh = self.AttributeTable_ToDataframe(layer_l_oh_lv[0])
                        # lines_lv_oh_layer = gp.read_file(layer[0] + ".shp")
                    except DriverError:
                        lines_lv_oh_layer = pd.DataFrame()
                        msg = "El nombre del archivo shp de la capa de "
                        msg += "líneas BT aéreas debe ser igual al nombre de la capa"
                        title = "Error al encontrar capa"
                        QMessageBox.information(None, title, msg)

                vect_lv.append(lines_lv_oh_layer)
                # Subterráneas
                if layer_l_ug_lv == [] or layer_l_ug_lv == 0:
                    lines_lv_ug_layer = pd.DataFrame()
                else:
                    try:
                        lines_lv_ug_layer, layer_lv_ug = self.AttributeTable_ToDataframe(layer_l_ug_lv[0])
                        # lines_lv_ug_layer = gp.read_file(layer[0] + ".shp")
                    except DriverError:
                        lines_lv_ug_layer = pd.DataFrame()
                        msg = "El nombre del archivo shp de la capa de "
                        msg += "líneas BT aéreas debe ser igual al nombre de la capa"
                        title = "Error al encontrar capa"
                        QMessageBox.information(None, title, msg)

                vect_lv.append(lines_lv_ug_layer)
                if lines_lv_oh_layer.empty and lines_lv_ug_layer.empty:
                    msg = "Debe existir la capa de líneas de baja tensión "
                    msg += "para poder ejecutar el programa correctamente"
                    title = "Error al encontrar capa"
                    # QMessageBox.information(None, title, msg)
                    # return
                # Acometidas
                if layer_acom == [] or layer_acom == 0:
                    acom = pd.DataFrame()
                else:
                    try:
                        for name_shape in layer_acom:
                            acom, layer_ac = self.AttributeTable_ToDataframe(name_shape)
                            # acom = gp.read_file(name_shape + ".shp")
                            vect_lv.append(acom)
                    except DriverError:
                        msg = "El nombre del archivo shp de la capa de "
                        msg += "acometidas debe ser igual al nombre de la capa"
                        title = "Error al encontrar capa"
                        QMessageBox.information(None, title, msg)

                # union capas de líneas
                lines_lv = pd.concat(vect_lv, sort=True)
                lines_lv.index = range(len(lines_lv.index))
                if lines_lv.empty is False:
                    try:
                        line_lv_groups = pd.DataFrame(list(lines_lv['LV_GROUP']),
                                                      index=lines_lv['DSSNAME'].astype(str),
                                                      columns=['LV_GROUP'])
                    except Exception:
                        self.print_error()
                        line_lv_groups = pd.DataFrame(list(lines_lv['LV_GROUP']),
                                                      index=lines_lv['DSSNAME'].astype(str),
                                                      columns=['LV_GROUP'])
                else:
                    line_lv_groups = pd.DataFrame()

                # TX info
                if layer_tx == [] or layer_tx == 0:
                    msg = "Debe existir la capa de transformadores "
                    msg += "para poder ejecutar el programa correctamente"
                    title = "Error al encontrar capa"
                    QMessageBox.information(None, title, msg)
                    return
                try:
                    vect_traf = []
                    for name_shape in layer_tx:
                        tx_layer, layer_trafos = self.AttributeTable_ToDataframe(name_shape)
                        # tx_layer = gp.read_file(name_shape + ".shp")
                        vect_traf.append(tx_layer)
                    tx_layer = pd.concat(vect_traf, sort=True)
                    tx_layer = tx_layer.drop(tx_layer.loc[tx_layer['DSSNAME'].isnull()].index.values)
                except DriverError:
                    msg = "El nombre del archivo shp de la capa de "
                    msg += "transformadores debe ser igual al nombre de la capa"
                    title = "Error al encontrar capa"
                    QMessageBox.information(None, title, msg)

                try:
                    tx_groups = pd.DataFrame(list(tx_layer['LV_GROUP']),
                                             index=tx_layer['DSSNAME'],
                                             columns=['LV_GROUP'])
                except Exception:
                    self.print_error()
                    tx_groups = pd.DataFrame(list(tx_layer['LV_GROUP']),
                                             index=tx_layer['DSSNAME'],
                                             columns=['LV_GROUP'])

                # Loads info
                # BT
                if layer_load_bt == [] or layer_load_bt == 0:
                    lv_loads_layer = pd.DataFrame()
                else:
                    try:
                        vect_loads = []
                        for name_shape in layer_load_bt:
                            lv_loads_layer, layer_loads_lv = self.AttributeTable_ToDataframe(name_shape)
                            # lv_loads_layer = gp.read_file(name_shape + ".shp")
                            vect_loads.append(lv_loads_layer)
                        lv_loads_layer = pd.concat(vect_loads, sort=True)

                    except DriverError:
                        lv_loads_layer = pd.DataFrame()
                        msg = "El nombre del archivo shp de la capa de "
                        msg += "cargas de BT debe ser igual al nombre de la capa"
                        title = "Error al encontrar capa"
                        QMessageBox.information(None, title, msg)

                # MT
                if layer_mt_loads == [] or layer_mt_loads == 0:
                    mv_loads_layer = pd.DataFrame()
                else:
                    try:
                        vect_loads = []
                        for name_shape in layer_mt_loads:
                            mv_loads_layer, layer_mv_loads = self.AttributeTable_ToDataframe(name_shape)
                            # mv_loads_layer = gp.read_file(name_shape + ".shp")
                            vect_loads.append(mv_loads_layer)
                        mv_loads_layer = pd.concat(vect_loads, sort=True)
                    except DriverError:
                        mv_loads_layer = pd.DataFrame()
                        msg = "El nombre del archivo shp de la capa de "
                        msg += "cargas de MT debe ser igual al nombre de la capa"
                        title = "Error al encontrar capa"
                        QMessageBox.information(None, title, msg)

                # Tienen que haber cargas de baja o de media
                if (mv_loads_layer.empty is True
                     and lv_loads_layer.empty is True):
                        msg = "Para poder ejecutar la herramienta "
                        msg += "deben existir cargas de media o baja "
                        msg += "tensión"
                        title = "Error al encontrar capas"
                        QMessageBox.information(None, title, msg)
                        return None

                # Pdevice info
                # Fusibles
                if layer_fuses == [] or layer_fuses == 0:
                    cols = ['PHASEDESIG', 'NC', 'OPERATINGV',  'bus1',
                            'bus2', 'DSSNAME', 'MV_GROUP', 'HC',
                            'SAVE','COORDINATE', 'geometry']
                    fuse_layer = pd.DataFrame(np.nan, columns=cols,
                                              index=[])
                else:
                    try:
                        fuse_layer, layer_fuses = self.AttributeTable_ToDataframe(layer_fuses[0])
                        # fuse_layer = gp.read_file(layer[0] + ".shp")
                        fuse_layer['HC'] = fuse_layer['HC'].apply(lambda x:
                                                                  unidecode(str(x)).strip().upper())
                        exp = (fuse_layer['HC'] == 'SI') | (fuse_layer['HC'] == 'YES')
                        fuse_layer = fuse_layer.loc[exp]
                        fuse_layer['bus1'] = fuse_layer['bus1'].str.replace('_swt', '')
                        fuse_layer['bus2'] = fuse_layer['bus2'].str.replace('_swt', '')
                    except DriverError:
                        cols = ['PHASEDESIG', 'NC', 'OPERATINGV',  'bus1',
                                'bus2', 'DSSNAME', 'MV_GROUP', 'HC',
                                'SAVE','COORDINATE', 'geometry']
                        fuse_layer = pd.DataFrame(np.nan, columns=cols,
                                                  index=[])
                        msg = "El nombre del archivo shp de la capa de "
                        msg += "fusibles debe ser igual al nombre de la capa"
                        title = "Error al encontrar capa"
                        QMessageBox.information(None, title, msg)
                    # fuse_layer = fuse_layer.iloc[0:2,:]

                # Reconectadores
                cols_rec = ['NOMVOLT','PHASEDESIG', 'NOMINALVOL',
                            'NC', 'HC', 'bus1', 'bus2', 'DSSNAME',
                            'MV_GROUP']
                if layer_rec == [] or layer_rec == 0:
                    recloser_layer = pd.DataFrame(np.nan, columns=cols_rec,
                                                  index=[])
                else:
                    try:
                        recloser_layer, layer_reclosers = self.AttributeTable_ToDataframe(layer_rec[0])
                        # recloser_layer = gp.read_file(layer[0] + ".shp")
                        recloser_layer['HC'] = recloser_layer['HC'].apply(lambda x:
                                                                          unidecode(str(x)).strip().upper())
                        exp = (recloser_layer['HC'] == 'SI') | (recloser_layer['HC'] == 'YES')
                        recloser_layer = recloser_layer.loc[exp]
                        recloser_layer['bus1'] = recloser_layer['bus1'].str.replace('_swt', '')
                        recloser_layer['bus2'] = recloser_layer['bus2'].str.replace('_swt', '')
                    except DriverError:
                        recloser_layer = pd.DataFrame(np.nan, columns=cols_rec,
                                                      index=[])
                        msg = "El nombre del archivo shp de la capa de "
                        msg += "reclosers debe ser igual al nombre de la capa"
                        title = "Error al encontrar capa"
                        QMessageBox.information(None, title, msg)
                
                start = time.time()
                firstLine = self.firstLine(dir_network)  # first line name
                if firstLine == 0:
                    return
                Circuit = self.dlg.lineEdit_circuit_name.text()
                # Name of the load curve of the circuit
                load_curve_circuit = self.dlg.lineEdit_load_curve.text()
                if load_curve_circuit:
                    with io.open(load_curve_circuit, 'rt', encoding = "ascii")as workbook:
                        try:
                            reader = csv.reader(workbook)
                            next(reader)

                            circuit_demand = [[row[3], row[2], row[0], row[1]] for row in
                                              reader]  #day, hour, P (kW), Q (kVAr)
                            workbook.closed
                        except Exception:
                            self.print_error()
                            msg = "Curva de demanda del alimentador errónea"
                            QMessageBox.information(None, "Informacion errónea", msg)
                            return None
                else:
                    msg = "Debe indicar la curva del alimentador"
                    QMessageBox.critical(None, "Error", msg)
                    return None

                snapshotdate = self.dlg.lineEdit_snapshot_date.text().upper()
                if not snapshotdate:
                        snapshotdate = auxfcns.selection_representative_day(load_curve_circuit, 'weekday')
                snapshottime = self.dlg.lineEdit_snapshot_time.text()

                # Se selecciona si es large scale (ls) o small scale (ss)
                current_index = self.dlg.tabWidget.currentIndex()
                ls = False
                ss = False

                if current_index == 0:
                    ls = True
                elif current_index == 1:
                    ss = True
                Overvoltage_analysis = False
                VoltageDeviation_analysis = False
                VoltageRegulation_analysis = False
                VoltageUnbalance = False
                Thermal_analysis = False

                RoR_analysis = False
                SympatheticTripping_analysis = False
                FF_analysis = False
                BFC_analysis = False

                tmp = setUpCOMInterface()
                DSSobj, DSSstart, DSStext, DSScircuit, DSSprogress = tmp
                Grafo = circuit_graph(nodes_mv, lines_mv)  # Grafo

                # ? Leer como en el rojo
                tx_modelling = True
                line_tx_definition = ''
                substation_type = ''
                
                # Creacion de master
                firstLine = self.create_master(dir_network, name_file_created,
                                       tx_modelling, volt_nom)
                print("firstLine = ", firstLine)

                # #####################################################
                # #####################################################
                # ############## GRAN ESCALA ##########################
                # #####################################################
                # #####################################################
                if ls is True:
                    """
                    Criterios de tensión:
                    Son simulaciones de flujo de potencia en estado estable (snapshot)
                    """
                    # Sobretensión
                    if self.dlg.overvoltage_ls.isChecked():
                        Overvoltage_analysis = True
                    # Regulación de tensión
                    if self.dlg.checkBox_regulation_ls.isChecked():
                        VoltageRegulation_analysis = True
                    # Desbalance de tensión
                    if self.dlg.unbalance_ls.isChecked():
                        VoltageUnbalance = True
                    # Desviación de tensión
                    if self.dlg.voltage_deviation_ls.isChecked():
                        VoltageDeviation_analysis = True
                    """
                    Criterios de protecciones:
                    Son simulaciones con fallas, cortos circuitos
                    """
                    # Aumento de corriente de falla
                    if self.dlg.cf_ls.isChecked():
                        FF_analysis = True
                        
                    # Disparo simpático
                    if self.dlg.st_ls.isChecked():
                        SympatheticTripping_analysis = True
                    # Coordinación recloser-fusible
                    if self.dlg.coord_rf_ls.isChecked():
                        BFC_analysis = True
                    # Reducción de alcance (RoR)
                    if self.dlg.rr_ls.isChecked():
                        RoR_analysis = True

                    # Criterios termicos
                    if self.dlg.cf_ls.isChecked():
                        Thermal_analysis = True

                    # Fallas seleccionadas
                    faulttypes = []
                    if self.dlg.Box_fails_ls.isEnabled():
                        if self.dlg.abcg_ls.isChecked():
                            faulttypes.append('ABCG')
                        if self.dlg.abg_ls.isChecked():
                            faulttypes.append('ABG')
                        if self.dlg.bcg_ls.isChecked():
                            faulttypes.append('BCG')
                        if self.dlg.acg_ls.isChecked():
                            faulttypes.append('ACG')
                        if self.dlg.ab_ls.isChecked():
                            faulttypes.append('AB')
                        if self.dlg.bc_ls.isChecked():
                            faulttypes.append('BC')
                        if self.dlg.ac_ls.isChecked():
                            faulttypes.append('AC')
                        if self.dlg.ag_ls.isChecked():
                            faulttypes.append('AG')
                        if self.dlg.bg_ls.isChecked():
                            faulttypes.append('BG')
                        if self.dlg.cg_ls.isChecked():
                            faulttypes.append('CG')
                    # Parámetros estudios
                    max_increase_bfc = self.dlg.inc_max_rf_ls.value()
                    max_reduction = self.dlg.red_max_ls.value()
                    max_reduction = 1 - max_reduction/100
                    Izero_trip = self.dlg.i_trip_ls.value()
                    max_increase_ff = self.dlg.max_perc_cf_ls.value()
                    max_increase_ff = 1 + max_increase_ff/100
                    max_lv_dev = self.dlg.unbalance_bt_ls.value()/100
                    max_mv_dev = self.dlg.unbalance_mt_ls.value()/100
                    max_v_unb = self.dlg.unb_max_ls.value()
                    max_v_unb = max_v_unb/100
                    max_v = self.dlg.overvolt_ls.value()
                    # Otros parámetros
                    TotalCapacityMax = self.dlg.maximum_capacity_ls.value()
                    der_step = self.dlg.steps_ls.value()
                    # Aporte de cortocircuito RD
                    icc_ls = self.dlg.ap_cc_ls.value()

                    # Caso en que no seleccione ningún análisis
                    if (Overvoltage_analysis is False and VoltageDeviation_analysis is False and
                            VoltageRegulation_analysis is False and VoltageUnbalance is False and
                            Thermal_analysis is False and RoR_analysis is False and
                            SympatheticTripping_analysis is False and FF_analysis is False
                            and BFC_analysis is False):
                        msg  = "No seleccionó ningún análisis"
                        title = "Final"
                        QMessageBox.information(None, title, msg)
                        return None

                    # Cálculos
                    vect = distance_nodes_MV(Grafo, nodes_mv, lines_mv, tx_layer, fixed_distance)
                    print("vect = ", vect)
                    chosen_buses_dict, chosen_buses_list, chosen_buses_df = vect
                    print("chosen_buses_df = ", chosen_buses_df)

                    # %% SALIDAS DE FUNCIONES QUE CREAN DATAFRAMES DE PROTECCIONES
                    CircuitBreakDvRoR, CircuitBreakDvFF_BFC = pDevices(Grafo, firstLine,
                                                                       fuse_layer, recloser_layer)
                    cols = ['BUSINST', 'VREG', 'BANDWIDTH']
					
                    if layer_reg != [] and layer_reg != 0:
                        RegDevices, regs_layer = self.AttributeTable_ToDataframe(layer_reg[0])
                        RegDevices = RegDevices[cols]
                        print("RegDevices = ", RegDevices)
                    else:
                        RegDevices = pd.DataFrame(np.nan, columns=cols, index=[])

                    # CIRCUIT BASE POWER FLOW
                    VBuses_b, Base_V = getbases(DSStext, DSScircuit, dir_network,
                                                firstLine, lv_groups, tx_groups)
                    loadslv_buses, loadsmv_buses = getloadbuses(circname_azul + '_LoadsLV',
                                                                circname_azul + '_LoadsMV',
                                                                dir_network)
                    # Gets all the loads buses # Gets all the loads buses
                    x = base_Case_Run(DSStext, DSScircuit,
                                      DSSobj, DSSprogress,
                                      snapshotdate, snapshottime,
                                      firstLine, tx_modelling, substation_type,
                                      line_tx_definition, circuit_demand, Base_V,
                                      CircuitBreakDvFF_BFC, CircuitBreakDvRoR,
                                      faulttypes, dir_network, lv_loads_layer,
                                      mv_loads_layer, tx_layer,
                                      FF_analysis, BFC_analysis,
                                      RoR_analysis)
                    NoDERsPF_Vbuses = x[0]
                    No_DER_FFCurrents = x[1]
                    No_DER_RoRCurrents = x[2]
                    No_DER_BFCCurrents = x[3]
                    kW_sim = x[4]
                    kVAr_sim = x[5]
                    lv_loads_layer = x[6]

                    # Verificar (si puede ser vacío sin errores)
                    if NoDERsPF_Vbuses.empty is True:
                        return None

                    normalAmpsDic = normalAmps(DSScircuit)  # Gets normal capacity for lines

                    MCSim = 1  # Total Monte Carlo Simulations
                   
                    # begins the HC study
                    # While loop. It'll stop when all the MV_Groups are flagged
                    # begin with the loop whose variable is distance

                    report_dict = {}  # dict with all the info.

                    for bus in chosen_buses_df.index.values:  # goes over the node step
                        start_t_bus = time.time()
                        report_dict[bus] = {}
                        report_dict[bus]['distance'] = chosen_buses_df.loc[bus, 'distance']
                        report_dict[bus]['max_kVA'] = 0
                        report_dict[bus]['vtp_criteria'] = {}

                        blacklist = []
                        blacklist_dict = {}

                        node_tuple = (bus, chosen_buses_df.loc[bus, 'nomvolt'])

                        Overvoltage_loads_df = pd.DataFrame()
                        Voltagedeviation_loads_df = pd.DataFrame()
                        Overvoltage_rest_df = pd.DataFrame()
                        Voltagedeviation_rest_df = pd.DataFrame()
                        Voltagedeviation_reg_df = pd.DataFrame()
                        Voltageunbalance_df = pd.DataFrame()
                        Thermal_loading_lines_df = pd.DataFrame()
                        Thermal_loading_tx_df = pd.DataFrame()
                        FFCurrents = pd.DataFrame()
                        RoRCurrents = pd.DataFrame()
                        BFCCurrents = pd.DataFrame()
                        SympatheticTripping_df = pd.DataFrame()
                        linelvgroups = []

                        # Now a node is selected, so we need to iterate over the
                        # installed capacity on that node
                        # to analyze the hosting capacity

                        flag = False
                        n_loop = 1
                        capacity_i = 0

                        while flag is False and n_loop*der_step <= TotalCapacityMax:
                            capacity_i = n_loop*der_step
                            blacklist = []
                            msg = "\nSimulation installed capacity: "
                            msg += str(capacity_i) + ' at bus:'
                            msg += str(node_tuple[0]) + ' distance: '
                            msg += str(chosen_buses_df.loc[bus, 'distance'])
                            print(msg)

                            # initialize the variables
                            Trafos = []
                            Trafos_Monitor = []
                            DERs = []

                            Trafos, Trafos_Monitor, DERs = trafos_and_DERs_text_command([node_tuple],
                                                                                        capacity_i)
                            # print(Trafos)

                            # Compile model for simulation - run simulation taking into
                            # consideration the new GD installed
                            DERs_Run(DSStext, DSScircuit, snapshotdate,
                                     snapshottime, firstLine,
                                     tx_modelling, substation_type,
                                     line_tx_definition, circuit_demand,
                                     Base_V, kW_sim, kVAr_sim,
                                     DERs, Trafos, dir_network)

                            # Check HC criteria - Here, the results
                            # dataframes are updated, with all limiting
                            # criteria characteristics being monitored
                            DSScircuit.setActiveElement('line.' + firstLine)
                            temp_powers = DSScircuit.ActiveElement.Powers
                            numb = temp_powers[0] + temp_powers[2] + temp_powers[4]
                            msg = 'P_w_Sub: ' + str(numb)
                            print(msg)

                            # Check HC criteria - Here, the results dataframes are
                            # updated, with all limiting criteria
                            # characteristics being monitored
                            x = pq_voltage(DSScircuit, DSStext, dir_network,
                                            Base_V, loadslv_buses, loadsmv_buses,
                                            RegDevices, capacity_i, lv_groups,
                                            tx_groups, NoDERsPF_Vbuses,
                                            Overvoltage_loads_df, Overvoltage_rest_df,
                                            Voltagedeviation_loads_df, Voltagedeviation_rest_df,
                                            Voltagedeviation_reg_df, Voltageunbalance_df,
                                            Overvoltage_analysis, VoltageDeviation_analysis,
                                            VoltageRegulation_analysis, VoltageUnbalance)
                            VBuses = x[0]
                            Overvoltage_loads_df = x[1]
                            Voltagedeviation_loads_df = x[2]
                            Overvoltage_rest_df = x[3]
                            Voltagedeviation_rest_df = x[4]
                            Voltagedeviation_reg_df = x[5]
                            Voltageunbalance_df = x[6]

                            x = thermal_Lines_Tx(DSScircuit, DSStext, normalAmpsDic,
                                                 capacity_i, line_lv_groups, tx_groups,
                                                 Thermal_loading_lines_df, Thermal_loading_tx_df,
                                                 name_file_created, linelvgroups, Thermal_analysis)
                            Thermal_loading_lines_df, Thermal_loading_tx_df, CurrentDF = x

                            FFCurrents, BFCCurrents = FF_BFC_Current(DSScircuit, DSStext,
                                                                     dir_network, firstLine,
                                                                     snapshottime, snapshotdate,
                                                                     kW_sim, kVAr_sim,  capacity_i,
                                                                     Trafos, DERs, No_DER_FFCurrents,
                                                                     FFCurrents, No_DER_BFCCurrents,
                                                                     BFCCurrents, faulttypes,
                                                                     FF_analysis, BFC_analysis)

                            RoRCurrents = ReductionReach(DSScircuit, DSStext,
                                                         dir_network, firstLine,
                                                         snapshottime, snapshotdate,
                                                         kW_sim, kVAr_sim, capacity_i,
                                                         Trafos, DERs, No_DER_RoRCurrents,
                                                         RoRCurrents, faulttypes, RoR_analysis)

                            SympatheticTripping_df = SympatheticTripping(DSStext, DSScircuit,
                                                                         dir_network, firstLine,
                                                                         snapshotdate, snapshottime,
                                                                         kW_sim, kVAr_sim, capacity_i,
                                                                         Trafos, DERs,
                                                                         SympatheticTripping_analysis,
                                                                         faulttypes, Izero_trip,
                                                                         SympatheticTripping_df)

                            msg = 'Checkpoint - distance= '
                            msg += str(chosen_buses_df.loc[bus, 'distance'])
                            msg += ' bus=' + str(node_tuple[0])
                            msg += ' Capacity: ' + str(capacity_i)
                            print(msg)

                            # at the end:
                            x = flag_and_blacklist_calc(Overvoltage_loads_df, Voltagedeviation_loads_df,
                                                        Overvoltage_rest_df, Voltagedeviation_rest_df,
                                                        Voltagedeviation_reg_df, Voltageunbalance_df,
                                                        Thermal_loading_lines_df, Thermal_loading_tx_df,
                                                        FFCurrents, BFCCurrents, RoRCurrents,
                                                        SympatheticTripping_df, Overvoltage_analysis,
                                                        VoltageDeviation_analysis, VoltageRegulation_analysis,
                                                        VoltageUnbalance, Thermal_analysis,
                                                        FF_analysis, BFC_analysis, RoR_analysis,
                                                        SympatheticTripping_analysis, tx_groups,
                                                        capacity_i, flag, blacklist, blacklist_dict)
                            flag, flag_list, blacklist, blacklist_dict, redo_sim = x

                            if flag is False:
                                if redo_sim is False:
                                    if capacity_i < TotalCapacityMax:
                                        print('Checkpoint - Capacity: '+str(capacity_i))
                                        #at the end:
                                        n_loop += 1
                                    else:
                                        msg = 'Final Checkpoint - Maximal capacity '
                                        msg += 'reached: ' + str(capacity_i)
                                        print(msg)
                                        final_der = capacity_i
                                        chosen_buses_df.loc[bus, 'max_kVA'] = final_der
                                        chosen_buses_df.loc[bus, 'flag'] = 'None'
                                        
                                        report_dict[bus]['max_kVA'] = final_der
                                        tmp = save_criteria_data_iterative(report_dict[bus]['vtp_criteria'],
                                                                           Overvoltage_loads_df,
                                                                           Voltagedeviation_loads_df, 
                                                                           Overvoltage_rest_df, Voltagedeviation_rest_df,
                                                                           Voltagedeviation_reg_df,
                                                                           Voltageunbalance_df,
                                                                           Thermal_loading_lines_df,
                                                                           Thermal_loading_tx_df,
                                                                           FFCurrents, BFCCurrents,
                                                                           RoRCurrents, SympatheticTripping_df)
                                        
                                        report_dict[bus]['vtp_criteria'] = tmp
                                        end_t_bus = time.time()
                                        sim_time_t_bus = end_t_bus - start_t_bus
                                        msg = 'Simulation time: '
                                        msg += str(round(sim_time_t_bus,2)) + ' sec.'
                                        print(msg)
                                        #at the end:
                                        n_loop += 1
                                else:
                                    final_der = capacity_i
                                    chosen_buses_df.loc[bus, 'max_kVA'] = final_der
                                    chosen_buses_df.loc[bus, 'flag'] = 'voltage/thermic'
                                    msg = 'Checkpoint - Capacity: ' + str(capacity_i)
                                    msg += '- there are voltage/thermic problems'
                                    print(msg)
                                    
                                    report_dict[bus]['max_kVA'] = final_der
                                    report_dict[bus]['vtp_criteria'] = save_criteria_data_iterative(report_dict[bus]['vtp_criteria'],
                                                                                                    Overvoltage_loads_df, Voltagedeviation_loads_df, 
                                                                                                    Overvoltage_rest_df, Voltagedeviation_rest_df,
                                                                                                    Voltagedeviation_reg_df, 
                                                                                                    Voltageunbalance_df, Thermal_loading_lines_df,
                                                                                                    Thermal_loading_tx_df, 
                                                                                                    FFCurrents, BFCCurrents,
                                                                                                    RoRCurrents, SympatheticTripping_df)
                                    flag = True
                                    end_t_bus = time.time()
                                    sim_time_t_bus = end_t_bus - start_t_bus
                                    msg = 'Simulation time: ' + str(round(sim_time_t_bus,2)) + ' sec.'
                                    print(msg)

                            else:
                                msg = 'Final Checkpoint - Maximal capacity reached: '
                                msg += str(capacity_i - der_step)
                                print(msg)
                                flag_list_str = ''
                                for crit in range(len(flag_list)):
                                    if len(flag_list) == 1:
                                        flag_list_str += flag_list[crit]
                                    else:
                                        if crit < (len(flag_list)-2):
                                            flag_list_str += flag_list[crit] + ', '
                                        elif crit == (len(flag_list)-2):
                                            flag_list_str += flag_list[crit] + ' and '
                                        else:
                                            flag_list_str += flag_list[crit]

                                msg = 'The ' + flag_list_str
                                msg += ' criteria forced the simulation to stop' 
                                print(msg)
                                final_der = capacity_i - der_step
                                chosen_buses_df.loc[bus, 'max_kVA'] = final_der
                                chosen_buses_df.loc[bus, 'flag'] = flag_list_str
                                
                                report_dict[bus]['max_kVA'] = final_der
                                tmp = save_criteria_data_iterative(report_dict[bus]['vtp_criteria'],
                                                                   Overvoltage_loads_df,
                                                                   Voltagedeviation_loads_df,
                                                                   Overvoltage_rest_df,
                                                                   Voltagedeviation_rest_df,
                                                                   Voltagedeviation_reg_df,
                                                                   Voltageunbalance_df,
                                                                   Thermal_loading_lines_df,
                                                                   Thermal_loading_tx_df,
                                                                   FFCurrents, BFCCurrents,
                                                                   RoRCurrents, SympatheticTripping_df)
                                report_dict[bus]['vtp_criteria'] = tmp
                                end_t_bus = time.time()
                                sim_time_t_bus = end_t_bus - start_t_bus
                                msg = 'Simulation time: '
                                msg += str(round(sim_time_t_bus,2)) + ' sec.'
                                print(msg)

                            if n_loop*der_step > TotalCapacityMax:
                                final_der = capacity_i
                                chosen_buses_df.loc[bus, 'max_kVA'] = final_der
                                chosen_buses_df.loc[bus, 'flag'] = 'Max_cap'

                                report_dict[bus]['max_kVA'] = final_der
                                tmp = save_criteria_data_iterative(report_dict[bus]['vtp_criteria'],
                                                                   Overvoltage_loads_df,
                                                                   Voltagedeviation_loads_df,
                                                                   Overvoltage_rest_df,
                                                                   Voltagedeviation_rest_df,
                                                                   Voltagedeviation_reg_df,
                                                                   Voltageunbalance_df,
                                                                   Thermal_loading_lines_df,
                                                                   Thermal_loading_tx_df,
                                                                   FFCurrents, BFCCurrents,
                                                                   RoRCurrents, SympatheticTripping_df)

                                report_dict[bus]['vtp_criteria'] = tmp
                                end_t_bus = time.time()
                                sim_time_t_bus = end_t_bus - start_t_bus
                                msg = 'Simulation time: ' + str(round(sim_time_t_bus,2))
                                msg += ' sec.\n'
                                msg += 'Final Checkpoint - The defined maximal '
                                msg += 'capacity was reached: ' + str(capacity_i)
                                print(msg)
                    
                    # Inicio
                    Voltage_comp  = Overvoltage_analysis and VoltageDeviation_analysis and VoltageRegulation_analysis and VoltageUnbalance
                    Prot_comp = FF_analysis and BFC_analysis and RoR_analysis

                    tmp = data_grouping_iterative(Grafo, chosen_buses_df, fixed_distance,
                                                  lines_mv, lines_mv_oh_layer_original,
                                                  lines_mv_ug_layer_original,
                                                  Voltage_comp,
                                                  Thermal_analysis, Prot_comp)
                    lines_mv_oh_layer_original = tmp[0]
                    lines_mv_ug_layer_original = tmp[1]
                    name_col = tmp[2]

                    # Guardan resultados
                    self.msg_final += "\nResultados gran escala:\n"
                    
                    col_sel = ['distance', 'max_kVA', 'flag']
                    try:
                        out_chosen_buses = chosen_buses_df[col_sel]
                        out_chosen_buses.to_csv(self.output + "/chosen_buses.csv")
                        self.msg_final += str(out_chosen_buses)
                    except Exception:
                        chosen_buses_df.to_csv(self.output + "/chosen_buses.csv")
                        self.msg_final += str(chosen_buses_df)
                    
                    # Se guardan los resultados en un txt
                    output_ = self.output + '/Resultados_ls.txt'
                    with open(output_, 'w') as file_:
                        file_.write(self.msg_final)
                    if layer_mt_aer != [] and layer_mt_aer != 0:
                        self.save_dataframe(lines_mv_oh_layer_original,
                                            layer_mv_oh, name_col)
                        self.categ_layer(lines_mv_oh_layer_original,
                                         layer_mv_oh, name_col)
                    if layer_mt_sub != [] and layer_mt_sub != 0:
                        self.save_dataframe(lines_mv_ug_layer_original,
                                            layer_mv_ug, name_col)
                        self.categ_layer(lines_mv_ug_layer_original,
                                            layer_mv_ug, name_col)
                    
                    if layer_mt_loads != [] and layer_mt_loads != 0:
                        self.save_dataframe(mv_loads_layer,
                                            layer_mv_loads, name_col)
                    # %% Reports how many minutes the simulation took
                    end = time.time()
                    sim_time = end - start
                    filename_ = self.output + '/Tsim.txt'
                    with open(filename_, 'w') as f:
                         f.write('El tiempo de simulacion fue: ' + str(sim_time))
                    f.close()
                    end = time.time()
                    sim_time = end - start
                    msg = 'Simulation time: ' + str(round(sim_time/60, 2)) + ' min.'
                    print(msg)

                # #####################################################
                # #####################################################
                # ################ PEQUEÑA ESCALA #####################
                # #####################################################
                # #####################################################
                if ss is True:
                    """
                    Criterios de tensión:
                    Son simulaciones de flujo de potencia en estado estable (snapshot)
                    """
                    # Sobretensión
                    if self.dlg.overvoltage_ss.isChecked():
                        Overvoltage_analysis = True
                        
                    # Regulación de tensión
                    if self.dlg.checkBox_regulation_ss.isChecked():
                        VoltageRegulation_analysis = True
                    # Desbalance de tensión
                    if self.dlg.unbalance_ss.isChecked():
                        VoltageUnbalance = True
                        
                    # Desviación de tensión
                    if self.dlg.voltage_deviation_ss.isChecked():
                        VoltageDeviation_analysis = True

                    # Limitar instalación máxima del trafo
                    if self.dlg.checkBox_lim_cap_traf.isChecked():
                        lim_kVA = True
                    else:
                        lim_kVA = False

                    """
                    Criterios de protecciones:
                    Son simulaciones con fallas, cortos circuitos
                    """
                    # Aumento de corriente de falla
                    if self.dlg.cf_ls.isChecked():
                        FF_analysis = True
                        
                    # Disparo simpático
                    if self.dlg.st_ss.isChecked():
                        SympatheticTripping_analysis = True
                        
                    # Coordinación recloser-fusible
                    if self.dlg.coord_rf_ss.isChecked():
                        BFC_analysis = True
                        
                    # Reducción de alcance (RoR)
                    if self.dlg.rr_ss.isChecked():
                        RoR_analysis = True
                        
                    # Criterios termicos
                    if self.dlg.cf_ls.isChecked():
                        Thermal_analysis = True

                    # Fallas seleccionadas
                    faulttypes = []
                    if self.dlg.Box_fails_ss.isEnabled():
                        if self.dlg.abcg_ss.isChecked():
                            faulttypes.append('ABCG')
                        if self.dlg.abg_ss.isChecked():
                            faulttypes.append('ABG')
                        if self.dlg.bcg_ss.isChecked():
                            faulttypes.append('BCG')
                        if self.dlg.acg_ss.isChecked():
                            faulttypes.append('ACG')
                        if self.dlg.ab_ss.isChecked():
                            faulttypes.append('AB')
                        if self.dlg.bc_ss.isChecked():
                            faulttypes.append('BC')
                        if self.dlg.ac_ss.isChecked():
                            faulttypes.append('AC')
                        if self.dlg.ag_ss.isChecked():
                            faulttypes.append('AG')
                        if self.dlg.bg_ss.isChecked():
                            faulttypes.append('BG')
                        if self.dlg.cg_ss.isChecked():
                            faulttypes.append('CG')
                    # Parametros de estudios
                    max_reduction = self.dlg.red_max_ss.value()
                    max_reduction = 1 - max_reduction/100
                    max_increase_bfc = self.dlg.inc_max_rf_ss.value()
                    Izero_trip = self.dlg.i_trip_ss.value()
                    max_increase_ff = self.dlg.max_perc_cf_ss.value()
                    max_increase_ff = 1 + max_increase_ff/100
                    max_v = self.dlg.overvolt_ss.value()
                    max_v_unb = self.dlg.unb_max_ss.value()
                    max_v_unb = max_v_unb/100
                    max_lv_dev = self.dlg.unbalance_bt_ss.value()/100
                    max_mv_dev = self.dlg.unbalance_mt_ss.value()/100
                    # Otros parámetros
                    TotalCapacityMax = self.dlg.maximum_capacity_ss.value()
                    max_kVA_step = self.dlg.steps_lv_ss.value()
                    max_kVA_mvloads = self.dlg.steps_mv_ss.value()
                    # Aporte de cortocircuito RD
                    icc_ss = self.dlg.ap_cc_ss.value()

                    # Caso en que no seleccione ningún análisis
                    if (Overvoltage_analysis is False and VoltageDeviation_analysis is False and
                            VoltageRegulation_analysis is False and VoltageUnbalance is False and
                            Thermal_analysis is False and RoR_analysis is False and
                            SympatheticTripping_analysis is False and FF_analysis is False
                            and BFC_analysis is False):
                        msg  = "No seleccionó ningún análisis"
                        title = "Final"
                        QMessageBox.information(None, title, msg)
                        return None

                    # %% SALIDAS DE FUNCIONES QUE CREAN DATAFRAMES DE PROTECCIONES
                    CircuitBreakDvRoR, CircuitBreakDvFF_BFC = pDevices(Grafo, firstLine,
                                                                    fuse_layer, recloser_layer)
                    cols = ['BUSINST', 'VREG', 'BANDWIDTH']
					
                    if layer_reg != [] and layer_reg != 0:
                        RegDevices, regs_layer = self.AttributeTable_ToDataframe(layer_reg[0])
                        RegDevices = RegDevices[cols]
                        print("RegDevices = ", RegDevices)
                    else:
                        RegDevices = pd.DataFrame(np.nan, columns=cols, index=[])
                    # %% CIRCUIT BASE POWER FLOW
                    VBuses_b, Base_V = getbases(DSStext, DSScircuit,
                                                dir_network, firstLine,
                                                lv_groups, tx_groups)
                    loadslv_buses, loadsmv_buses = getloadbuses(circname_azul + '_LoadsLV',
                                                                circname_azul + '_LoadsMV',
                                                                dir_network)
                    # Gets all the loads buses # Gets all the loads buses
                    vect_ret = base_Case_Run(DSStext, DSScircuit, DSSobj, DSSprogress,
                                            snapshotdate, snapshottime, firstLine,
                                            tx_modelling, substation_type, line_tx_definition,
                                            circuit_demand, Base_V, CircuitBreakDvFF_BFC,
                                            CircuitBreakDvRoR, faulttypes, dir_network,
                                            lv_loads_layer, mv_loads_layer, tx_layer,
                                            FF_analysis, BFC_analysis, RoR_analysis)
                    NoDERsPF_Vbuses = vect_ret[0]
                    No_DER_FFCurrents = vect_ret[1]
                    No_DER_RoRCurrents = vect_ret[2]
                    No_DER_BFCCurrents = vect_ret[3]
                    kW_sim = vect_ret[4]
                    kVAr_sim = vect_ret[5]
                    lv_loads_layer = vect_ret[6]

                    normalAmpsDic = normalAmps(DSScircuit) # Gets normal capacity for lines

                    Overvoltage_loads_df = pd.DataFrame()
                    Voltagedeviation_loads_df = pd.DataFrame()
                    Overvoltage_rest_df = pd.DataFrame()
                    Voltagedeviation_rest_df = pd.DataFrame()
                    Voltagedeviation_reg_df = pd.DataFrame()
                    Voltageunbalance_df = pd.DataFrame()
                    Thermal_loading_lines_df = pd.DataFrame()
                    Thermal_loading_tx_df = pd.DataFrame()
                    FFCurrents = pd.DataFrame()
                    RoRCurrents = pd.DataFrame()
                    BFCCurrents = pd.DataFrame()
                    SympatheticTripping_df = pd.DataFrame()
                    linelvgroups = []

                    # Función para tomar la info de txs y mvloads
                    LoadTrafos_MVLoads = base_info_tx_and_mvloads(DSScircuit, DSSobj,
                                                                DSStext, Grafo, tx_layer,
                                                                mv_loads_layer)
                    # Función para tomar la info de las lv_loads
                    LV_hist_df, blacklist_ini = base_info_lvloads(lv_loads_layer,
                                                                LoadTrafos_MVLoads,
                                                                DSScircuit)

                    # %% Hosting capacity analysis
                    MCSim = 1  # Total Monte Carlo Simulations
                    MV_hist_df, LV_hist_df = DER_calc(0, 0,
                                                    LoadTrafos_MVLoads,
                                                    blacklist_ini, LV_hist_df)
                    # blacklist dictionary
                    blacklist_dict = {}
                    blacklist_dict[0] = blacklist_ini

                    # iterative blacklist (it updates itself with every iteration)
                    blacklist = []
                    blacklist += blacklist_ini

                    # begins the HC study
                    # While loop. It'll stop when all the MV_Groups are flagged

                    flag = False
                    # calculate initial capacity to install
                    capacity_i = 0
                    time_data = {}
                    final_der = -1

                    while flag is False and capacity_i <= TotalCapacityMax:
                        # DER asignation
                        start_t_sim = time.time()

                        # DER asignation
                        tmp = step_calc(MV_hist_df, blacklist, 
                                         blacklist_dict, max_kVA_step,
                                         max_kVA_mvloads, lim_kVA, capacity_i)
                        der_step, capacity_i, MV_hist_df, temp_blacklist = tmp

                        len1 = len(list(set(temp_blacklist + blacklist)))
                        len2 = len(MV_hist_df.index)
                        if len1 == len2 or (capacity_i >= TotalCapacityMax): 
                            MV_hist_df.loc[temp_blacklist, 'blacklist_info'] = np.nan
                            msg = 'Final Checkpoint - Maximal capacity '
                            msg += 'reached: ' + str(capacity_i - der_step)
                            print(msg)
                            final_der = capacity_i - der_step
                            flag = True

                        else:
                            print()
                            msg = 'Simulation installed '
                            msg += 'capacity: ' + str(capacity_i)
                            print(msg)

                            MV_hist_df, LV_hist_df = DER_calc(capacity_i, der_step, LoadTrafos_MVLoads,
                                                            blacklist, LV_hist_df, MV_hist_df)

                            # initialize the variables
                            DERs_LV = []
                            DERs_MV = []
                            Trafos_DERs_MV = []

                            trafo_df_f = pd.DataFrame()
                            DERs_LV, DERs_MV, Trafos_DERs_MV = DER_allocation_HHC(LV_hist_df, MV_hist_df,
                                                                                  mv_loads_layer,
                                                                                  trafo_df_f)
                            DERs = DERs_LV + DERs_MV

                            # Compile model for simulation - run simulation
                            # taking into consideration the new GD installed
                            DERs_Run(DSStext, DSScircuit, snapshotdate,
                                    snapshottime, firstLine, tx_modelling,
                                    substation_type, line_tx_definition,
                                    circuit_demand, Base_V, kW_sim,
                                    kVAr_sim, DERs, Trafos_DERs_MV,
                                    dir_network)

                            DSScircuit.setActiveElement('line.' + firstLine)
                            temp_powers = DSScircuit.ActiveElement.Powers
                            val = temp_powers[0] + temp_powers[2]
                            val += temp_powers[4]
                            msg = 'P_w_Sub: ' + str(val)
                            print(msg)

                            # Check HC criteria - Here, the results dataframes are
                            # updated, with all limiting criteria characteristics being monitored
                            vect_ret =  pq_voltage(DSScircuit, DSStext, dir_network,
                                                Base_V, loadslv_buses, loadsmv_buses,
                                                RegDevices, capacity_i, lv_groups,
                                                tx_groups, NoDERsPF_Vbuses,
                                                Overvoltage_loads_df, Overvoltage_rest_df,
                                                Voltagedeviation_loads_df, Voltagedeviation_rest_df,
                                                Voltagedeviation_reg_df, Voltageunbalance_df,
                                                Overvoltage_analysis, VoltageDeviation_analysis,
                                                VoltageRegulation_analysis, VoltageUnbalance)
                            VBuses = vect_ret[0]
                            Overvoltage_loads_df = vect_ret[1]
                            Voltagedeviation_loads_df = vect_ret[2]
                            Overvoltage_rest_df = vect_ret[3]
                            Voltagedeviation_rest_df = vect_ret[4]
                            Voltagedeviation_reg_df = vect_ret[5]
                            Voltageunbalance_df = vect_ret[6]

                            vect_ret = thermal_Lines_Tx(DSScircuit, DSStext, normalAmpsDic,
                                                        capacity_i, line_lv_groups,
                                                        tx_groups, Thermal_loading_lines_df,
                                                        Thermal_loading_tx_df, name_file_created,
                                                        linelvgroups, Thermal_analysis)
                            Thermal_loading_lines_df = vect_ret[0]
                            Thermal_loading_tx_df = vect_ret[1]
                            CurrentDF = vect_ret[2]

                            FFCurrents, BFCCurrents = FF_BFC_Current(DSScircuit, DSStext,
                                                                    dir_network, firstLine,
                                                                    snapshottime, snapshotdate,
                                                                    kW_sim, kVAr_sim, capacity_i,
                                                                    Trafos_DERs_MV, DERs,
                                                                    No_DER_FFCurrents, FFCurrents,
                                                                    No_DER_BFCCurrents, BFCCurrents,
                                                                    faulttypes, FF_analysis, BFC_analysis)

                            RoRCurrents = ReductionReach(DSScircuit, DSStext,
                                                        dir_network, firstLine,
                                                        snapshottime, snapshotdate,
                                                        kW_sim, kVAr_sim, capacity_i,
                                                        Trafos_DERs_MV, DERs,
                                                        No_DER_RoRCurrents, RoRCurrents,
                                                        faulttypes, RoR_analysis)

                            SympatheticTripping_df = SympatheticTripping(DSStext, DSScircuit,
                                                                        dir_network, firstLine,
                                                                        snapshotdate, snapshottime,
                                                                        kW_sim, kVAr_sim, capacity_i,
                                                                        Trafos_DERs_MV, DERs,
                                                                        SympatheticTripping_analysis, faulttypes,
                                                                        Izero_trip, SympatheticTripping_df)

                            new_ret = flag_and_blacklist_calc(Overvoltage_loads_df, Voltagedeviation_loads_df,
                                                            Overvoltage_rest_df, Voltagedeviation_rest_df,
                                                            Voltagedeviation_reg_df, Voltageunbalance_df,
                                                            Thermal_loading_lines_df, Thermal_loading_tx_df,
                                                            FFCurrents, BFCCurrents, RoRCurrents,
                                                            SympatheticTripping_df, Overvoltage_analysis,
                                                            VoltageDeviation_analysis, VoltageRegulation_analysis,
                                                            VoltageUnbalance, Thermal_analysis,
                                                            FF_analysis, BFC_analysis, RoR_analysis,
                                                            SympatheticTripping_analysis, MV_hist_df,
                                                            capacity_i, flag, blacklist, blacklist_dict)
                            flag = new_ret[0]
                            flag_list = new_ret[1]
                            blacklist = new_ret[2]
                            blacklist_dict = new_ret[3]
                            redo_sim = new_ret[4]
                            end_t_sim = time.time()
                            time_data[capacity_i] = end_t_sim - start_t_sim

                            if flag is False:
                                if redo_sim is False:
                                    if capacity_i <= TotalCapacityMax:
                                        msg = 'Checkpoint - Capacity: '
                                        msg += str(capacity_i)
                                        print(msg)
                                        topped_tx = list(set(temp_blacklist) - set(blacklist))
                                        blacklist_dict[capacity_i] += topped_tx
                                        blacklist = list(set(blacklist + temp_blacklist))  # update
                                        MV_hist_df.loc[topped_tx, 'blacklist_info'] = 'topped_tx'
                                        # at the end:
                                        # capacity_i += der_step
                                    else:
                                        msg = 'Final Checkpoint - Maximal capacity '
                                        msg += 'reached: ' + str(capacity_i-der_step)
                                        print(msg)
                                        final_der = capacity_i - der_step
                                        # at the end:
                                        # capacity_i += der_step

                                else:
                                    msg = 'Checkpoint - Capacity: '
                                    msg += str(capacity_i) + '- there are voltage'
                                    msg += '/thermic problems, the analysis will '
                                    msg += 'be repeated by fixing the previous assigned '
                                    msg += 'capacity on the transformers with problems '
                                    msg += 'and reassigning the DER capacity of the iteration '
                                    msg += 'on the transformers(secondaries) without problems '
                                    print(msg)
                                    MV_hist_df = MV_hist_df.drop(columns=[capacity_i])
                                    for group in LV_hist_df:
                                        LV_hist_df[group] = LV_hist_df[group].drop(columns=[capacity_i])
                                    # comes back to the previous analysed level
                                    capacity_i = capacity_i - der_step

                            else:
                                msg = 'Final Checkpoint - Maximal '
                                msg += 'capacity reached: ' + str(capacity_i - der_step)
                                print(msg)
                                flag_list_str = ''
                                for crit in range(len(flag_list)):
                                    if len(flag_list) == 1:
                                        flag_list_str += flag_list[crit]
                                    else:
                                        if crit < (len(flag_list)-2):
                                            flag_list_str += flag_list[crit] + ', '
                                        elif crit == (len(flag_list)-2):
                                            flag_list_str += flag_list[crit] + ' and '
                                        else:
                                            flag_list_str += flag_list[crit]

                                msg = 'The ' + flag_list_str
                                msg += ' criteria forced the simulation to stop'
                                print(msg)
                                final_der = capacity_i - der_step

                    # Reports how many minutes the simulation took
                    end = time.time()
                    whole_sim_time = end - start
                    time_data['total'] = whole_sim_time
                    msg = 'Simulation time: '
                    msg += str(round(whole_sim_time/60, 2))
                    msg += ' min.'
                    print(msg)

                    # %% SAVE ON LAYER
                    Voltage_comp = Overvoltage_analysis or VoltageDeviation_analysis \
                                        or VoltageRegulation_analysis \
                                        or VoltageUnbalance
                    Prot_comp = FF_analysis or BFC_analysis or RoR_analysis

                    for elem in MV_hist_df.index:
                        try:
                            idx_tx = tx_layer.loc[tx_layer['DSSNAME'] == elem].index.values[0]

                            if lim_kVA is True:
                                if (Voltage_comp is True and Thermal_analysis is True
                                        and Prot_comp is True):
                                    tx_layer.loc[idx_tx, 'HB_M-VTP'] = MV_hist_df.loc[elem, final_der]
                                elif (Voltage_comp is True and Thermal_analysis is True
                                        and Prot_comp is False):
                                    tx_layer.loc[idx_tx, 'HB_M-VT'] = MV_hist_df.loc[elem, final_der]
                                elif (Voltage_comp is True and Thermal_analysis is False
                                        and Prot_comp is False):  # error aca
                                    tx_layer.loc[idx_tx, 'HB_M-V'] = MV_hist_df.loc[elem, final_der]
                            else:
                                if (Voltage_comp is True and Thermal_analysis is True
                                        and Prot_comp is True):
                                    tx_layer.loc[idx_tx, 'HB_VTP'] = MV_hist_df.loc[elem, final_der]
                                elif (Voltage_comp is True and Thermal_analysis is True
                                        and Prot_comp is False):
                                    tx_layer.loc[idx_tx, 'HB_VT'] = MV_hist_df.loc[elem, final_der]
                                elif (Voltage_comp is True and Thermal_analysis is False
                                        and Prot_comp is False):
                                    tx_layer.loc[idx_tx, 'HB_V'] = MV_hist_df.loc[elem, final_der]
                        except Exception:
                            pass
                    x = data_grouping(Grafo, MV_hist_df, fixed_distance, final_der,
                                      lines_mv_oh_layer_original,
                                      lines_mv_ug_layer_original, Voltage_comp,
                                      Thermal_analysis, Prot_comp, lim_kVA)
                    lines_mv_oh_layer_original = x[0]
                    lines_mv_ug_layer_original = x[1]
                    name_col = x[2]
                    
                    # Caso en que hayan habido errores
                    if lines_mv_oh_layer_original.empty:
                        return None
                    if layer_mt_aer != [] and layer_mt_aer != 0:
                        self.save_dataframe(lines_mv_oh_layer_original,
                                            layer_mv_oh, name_col)
                        self.categ_layer(lines_mv_oh_layer_original,
                                         layer_mv_oh, name_col)
                        # lines_mv_oh_layer_original.to_csv(dir_network + "/Mt_aer.csv")
                        # lines_mv_oh_layer_original.to_file(layer_mt_aer[0] + ".shp")
                    if layer_mt_sub != [] and layer_mt_sub != 0:
                        self.save_dataframe(lines_mv_ug_layer_original,
                                            layer_mv_ug, name_col)
                        self.categ_layer(lines_mv_ug_layer_original,
                                         layer_mv_ug, name_col)
                    if layer_mt_loads != [] and layer_mt_loads != 0:
                        self.save_dataframe(mv_loads_layer,
                                            layer_mv_loads, name_col)
                    MV_hist_df.to_csv(self.output + "/MV_hist_df.csv")
                    # Se cambia el nombre de la columna
                    MV_hist_df.rename({final_der: name_col}, axis=1, inplace=True)  # new method
                    self.save_dataframe(MV_hist_df, layer_trafos, name_col)
                    
                    self.msg_final += "\nCapacidad final pequeña escala:\n" + str(final_der)
                    self.msg_final += " kVA.\nLa capacidad de alojamiento está "
                    self.msg_final += "limitada por " + str(flag_list)
                    # Se guardan los resultados en un txt
                    output_ = self.output + '/Resultados_ss.txt'
                    with open(output_, 'w') as file_:
                        file_.write(self.msg_final)
                msg  = "Simulación finalizada exitosamente"
                title = "Final"
                msg += "\nLos resultados se guardaron en el siguiente "
                msg += "directorio: " + self.output
                QMessageBox.information(None, title, msg)
        except Exception:
            title = "Final"
            msg = "Simulación finalizada con errores"
            self.print_error()
            QMessageBox.critical(None, title, msg)
            
