# -*- coding: utf-8 -*-
"""
/***************************************************************************
 ired
                                 A QGIS plugin
 Integración de Recursos Energéticos Distribuidos
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2020-11-13
        git sha              : $Format:%H$
        copyright            : (C) 2020 by EPERLab
        email                : eperlab.eie@ucr.ac.cr
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction
from .QGIS_run_OpenDSS_transformer import Ui_Transformer

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .ired_dialog import iredDialog
import os.path
from qgis.core import NULL
from qgis.PyQt.QtWidgets import QFileDialog, QMessageBox
import traceback
import glob
import pandas as pd
import re
import csv
import traceback
from qgis.core import QgsProject
from qgis.PyQt.QtGui import QDesktopServices
from qgis.PyQt.QtCore import QUrl
import subprocess
import sys
import numpy as np
import time
import io
import copy
import matplotlib
from qgis.core import QgsSymbol
from qgis.core import QgsLineSymbol
from qgis.core import QgsRendererRange
from qgis.core import QgsGraduatedSymbolRenderer
from qgis.core import QgsField, QgsFields, QgsFeature
from PyQt5.QtCore import QVariant
from PyQt5.QtGui import QColor
from qgis.utils import iface
from matplotlib import pyplot as plt
from .Hybrid_Iterative_Functions import *
from . import auxiliary_functions as auxfcns
from typing import Optional

pd.options.mode.chained_assignment = None


class ired:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        if locale != (u'en'):
            locale = (u'es')
            
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'en2.qm')
            
        print(locale_path)

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&IRED')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.dlg = iredDialog()
        # Ventana del transformador principal
        self.transformer = Ui_Transformer()
        type_tx_conns = [QCoreApplication.translate('dialog', 'Estrella'),
                         QCoreApplication.translate('dialog', 'Delta')]
        self.transformer.comboBox_conn_high.clear()
        self.transformer.comboBox_conn_high.addItems(type_tx_conns)
        self.transformer.comboBox_conn_tertiary.clear()
        self.transformer.comboBox_conn_tertiary.addItems(type_tx_conns)
        self.transformer.comboBox_conn_low.clear()
        self.transformer.comboBox_conn_low.addItems(type_tx_conns)
        type_tx_conns = ['wye', 'delta']
        tap_location = [QCoreApplication.translate('dialog', 'Alta'),
                        QCoreApplication.translate('dialog', 'Baja')]
        self.transformer.comboBox_tap_location.clear()
        self.transformer.comboBox_tap_location.addItems(tap_location)

        # Configuracion de señales en caratula
        self.start_gui()
        self.output = ""

    """
    Función para inicializar los aspectos de la interfaz gráfica
    """
    def start_gui(self):
        self.dlg.buttonBox.helpRequested.connect(self.show_help)
        self.dlg.pushButton_output_folder.clicked.connect(self.select_output_folder)
        self.dlg.pushButton_load_curve.clicked.connect(self.select_demand_curve)
        # self.dlg.pushButton_transformer.clicked.connect(self.transformer_button)

        # Habilitación de checks de tipos de fallas ls
        self.dlg.cf_ls.toggled.connect(self.enabler_faults_ls)
        self.dlg.st_ls.toggled.connect(self.enabler_faults_ls)
        self.dlg.coord_rf_ls.toggled.connect(self.enabler_faults_ls)
        self.dlg.rr_ls.toggled.connect(self.enabler_faults_ls)

        # Habilitación de checks de tipos de fallas ss
        self.dlg.cf_ss.toggled.connect(self.enabler_faults_ss)
        self.dlg.st_ss.toggled.connect(self.enabler_faults_ss)
        self.dlg.coord_rf_ss.toggled.connect(self.enabler_faults_ss)
        self.dlg.rr_ss.toggled.connect(self.enabler_faults_ss)
        
        # Habilitación de checks para tipo de DER a simular
        self.dlg.DER_PV.toggled.connect(self.select_type_DER)
        self.dlg.DER_MS.toggled.connect(self.select_type_DER)

        # Tab siempre iniciará en estudios base
        self.dlg.tabWidget.setCurrentIndex(0)

    def show_help(self):
        """Display application help to the user."""

        help_file = 'file:///%s/help/Manual-HerramientaIRED.pdf' % self.plugin_dir
        # For testing path:
        # QMessageBox.information(None, 'Help File', help_file)
        # noinspection PyCallByClass,PyTypeChecker
        QDesktopServices.openUrl(QUrl(help_file))

    # Función que habilita o deshabilita los tipos de falla en ls
    def enabler_faults_ls(self):
        # Se habilitan las fallas en ls
        if (self.dlg.cf_ls.isChecked() or self.dlg.st_ls.isChecked()
                or self.dlg.coord_rf_ls.isChecked()
                or self.dlg.rr_ls.isChecked()):
            self.dlg.Box_faults_ls.setEnabled(True)
        else:
            self.dlg.Box_faults_ls.setEnabled(False)

    # Función que habilita o deshabilita los tipos de falla en ss
    def enabler_faults_ss(self):
        # Se habilitan las fallas en ls
        if (self.dlg.cf_ss.isChecked() or self.dlg.st_ss.isChecked()
                or self.dlg.coord_rf_ss.isChecked()
                or self.dlg.rr_ss.isChecked()):
            self.dlg.Box_faults_ss.setEnabled(True)
        else:
            self.dlg.Box_faults_ss.setEnabled(False)

    # Funcion para habilitar o deshabilitar estudios de fallas
    def enabler_protection_analysis(self):
        if self.protections is True:
            self.dlg.cf_ss.setEnabled(True)
            self.dlg.st_ss.setEnabled(True)
            self.dlg.rr_ss.setEnabled(True)
            self.dlg.Box_faults_ss.setEnabled(True)
            self.dlg.cf_ls.setEnabled(True)
            self.dlg.st_ls.setEnabled(True)
            self.dlg.rr_ls.setEnabled(True)
            self.dlg.Box_faults_ls.setEnabled(True)
        else:
            self.dlg.cf_ss.setEnabled(False)
            self.dlg.cf_ss.setChecked(False)
            self.dlg.st_ss.setEnabled(False)
            self.dlg.st_ss.setChecked(False)
            self.dlg.rr_ss.setEnabled(False)
            self.dlg.rr_ss.setChecked(False)
            self.dlg.Box_faults_ss.setEnabled(False)
            self.dlg.cf_ls.setEnabled(False)
            self.dlg.cf_ls.setChecked(False)
            self.dlg.st_ls.setEnabled(False)
            self.dlg.st_ls.setChecked(False)
            self.dlg.rr_ls.setEnabled(False)
            self.dlg.rr_ls.setChecked(False)
            self.dlg.Box_faults_ls.setEnabled(False)

        # La coordinacion recloser fusible sólo
        # se habilita si hay reclosers y fusibles
        if self.rec_fus is True:
            self.dlg.coord_rf_ss.setEnabled(True)
            self.dlg.coord_rf_ls.setEnabled(True)
        else:
            self.dlg.coord_rf_ss.setEnabled(False)
            self.dlg.coord_rf_ss.setChecked(False)
            self.dlg.coord_rf_ls.setEnabled(False)
            self.dlg.coord_rf_ls.setChecked(False)

                    
    # Muestra la ventana del transformador principal
    def transformer_button(self):
        self.transformer.show()

    # fill the circuit comboBox
    def circuit_calling(self):
        try:
            self.dlg.lineEdit_circuit_name.clear()
            prjpath = QgsProject.instance().fileName()
            if not prjpath:
                msg = "El projecto en QGIS debe estar abierto para "
                msg += "poder analizar el circuito de distribución"
                title = "Error al leer proyecto GIS"
                QMessageBox.information(None, title, msg)
                return 0, 0, 0
            dir_general, dir_general2 = prjpath.split('/GIS', 1)
            # Folder where all network models are stored
            dir_network = dir_general + '/DSS'
            os.chdir(dir_network)
            networks = dir_general.split('/')[-1]
            self.dlg.lineEdit_circuit_name.setText(networks)
            # self.dlg.comboBox_circuit_name.addItems(networks)
            return prjpath, dir_general, dir_network
        except Exception:
            self.print_error()
            aviso = "El projecto en QGIS debe poseer el formato establecido "
            aviso += "en el manual y ya deben existir los archivos *.dss"
            title = "Error al leer información del circuito"
            QMessageBox.information(None, title, aviso)
            return 0, 0, 0

    # Method to select the output folder
    def select_output_folder(self):
        msg = "Seleccione carpeta de salida"
        msg_tr = QCoreApplication.translate('dialog', msg)
        output_folder = QFileDialog.getExistingDirectory(self.dlg, msg_tr, "",)
        self.dlg.lineEdit_dirOutput.setText(output_folder)

    # Method to select the demand curve of the circuit
    def select_demand_curve(self):
        msg = "Seleccione el archivo .CSV para asignar curva de "
        msg += "demanda de circuito"
        msg_tr = QCoreApplication.translate('dialog', msg)
        load_curve_circuit = QFileDialog.getOpenFileName(self.dlg, msg_tr,
                                                         "", "*.csv")
        load_curve_circuit = load_curve_circuit[0]
        print("load_curve_circuit = ", str(load_curve_circuit))
        self.dlg.lineEdit_load_curve.setText(load_curve_circuit)
    
    # Función para solo activar la opción de aporte de corto o impedancia de máquina
    # de acuerdo a lo seleccionado en el estudio de gran escala
    
    def select_type_DER(self):
    
        if self.dlg.DER_PV.isChecked():
            self.dlg.ap_cc_ls.setEnabled(True)
            self.dlg.ap_ms.setEnabled(False)
        else:
            self.dlg.ap_cc_ls.setEnabled(False)
            self.dlg.ap_ms.setEnabled(True)
        

    """
    *******************************************************************
    *******************************************************************
    Función cktNameDefaults
    Se encarga de la lectura del archivo de salida del azul para poder
    encontrar el nombre de una capa en específico

    -Parámetros de entrada:
    *dir_general (str): directorio donde está el GIS
    *dir_network (str): directorio donde están los archivos dss


    -Valores retornados
    *voltage (int): tensión del circuito (media tensión)
    *******************************************************************
    *******************************************************************
    """

    # change the parameters according to the selected circuit
    def cktNameDefaults(self, dir_general, dir_network):
        try:
            voltage = 0
            os.chdir(dir_network)
            for file in glob.glob("*.dss"):
                file_check = re.sub('\.dss$', '', file)
                file_check = file_check[-10:]
                file_name = re.sub('\.dss$', '', file).replace('_' + file_check, '')
                if file_check == 'Substation':
                    file_name_path = str(os.getcwd()) + '\\' + '\\' + file
                    fp = open(file_name_path)
                    lines = fp.readlines()
                    line_ = lines[1]
                    line = line_.split(' ')

                    # Corriente de corto circuit subestación
                    # Monofásica
                    str_search = "isc1p="
                    in_isc1 = line_.find(str_search)
                    if in_isc1 != -1:
                        in_isc1 = line_.find("isc1p=")
                        in_isc1 += len(str_search)
                        fin_isc1 = line_.find(" ", in_isc1)
                        isc1p = line_[in_isc1:fin_isc1]
                    else:
                        isc1p = ""
                    # Trifásica
                    str_search = "isc3p="
                    in_isc3 = line_.find(str_search)
                    if in_isc3 != -1:
                        in_isc3 = line_.find("isc3p=")
                        in_isc3 += len(str_search)
                        fin_isc3 = line_.find(" ", in_isc3)
                        isc3p = line_[in_isc3:fin_isc3]
                    else:
                        isc3p = ""
                    if self.dlg.lineEdit_3pShortCircuitPower.text() == '':
                        if isc3p == "":
                            self.dlg.lineEdit_3pShortCircuitPower.setText('10')
                        else:
                            self.dlg.lineEdit_3pShortCircuitPower.setText(isc3p)

                    if self.dlg.lineEdit_1pShortCircuitPower.text() == '':
                        if isc1p == "":
                            self.dlg.lineEdit_1pShortCircuitPower.setText('10.5')
                        else:
                            self.dlg.lineEdit_1pShortCircuitPower.setText(isc1p)

                    if "UNIT" in lines[0]:  # substation is single unit
                        self.transformer.checkBox_tertiary.setCheckState(0)
                        for ij in range(len(line)):
                            line_check = line[ij]
                            # Windings fillup
                            if line_check == 'windings=3':
                                self.transformer.checkBox_tertiary.setCheckState(1)
                                # Voltages fillup
                            if line_check[:5] == 'kVs=[':
                                def_V_prim = line_check.replace('kVs=[', '')
                                voltage = def_V_prim
                                self.transformer.lineEdit_voltage_high.clear()
                                self.transformer.lineEdit_voltage_high.setText(def_V_prim)
                                V_ter = line[ij + 2]
                                if V_ter[-1:] == ']':
                                    V_sec = line[ij + 1]
                                    self.transformer.lineEdit_voltage_low.clear()
                                    self.transformer.lineEdit_voltage_low.setText(V_sec)
                                    V_ter = V_ter.replace(']', '')
                                    self.transformer.lineEdit_voltage_tertiary.clear()
                                    self.transformer.lineEdit_voltage_tertiary.setText(V_ter)
                                else:
                                    V_sec = line[ij + 1]
                                    V_sec = V_sec.replace(']', '')
                                    self.transformer.lineEdit_voltage_low.clear()
                                    self.transformer.lineEdit_voltage_low.setText(V_sec)
                            # Powers fillup
                            if line_check[:6] == 'kVAs=[':
                                P_prim = line_check.replace('kVAs=[', '')
                                self.transformer.lineEdit_power_high.clear()
                                self.transformer.lineEdit_power_high.setText(P_prim)
                                P_ter = line[ij + 2]
                                if P_ter[-1:] == ']':
                                    P_sec = line[ij + 1]
                                    self.transformer.lineEdit_power_low.clear()
                                    self.transformer.lineEdit_power_low.setText(P_sec)
                                    P_ter = P_ter.replace(']', '')
                                    self.transformer.lineEdit_power_tertiary.clear()
                                    self.transformer.lineEdit_power_tertiary.setText(P_ter)
                                else:
                                    P_sec = line[ij + 1]
                                    P_sec = P_sec.replace(']', '')
                                    self.transformer.lineEdit_power_low.clear()
                                    self.transformer.lineEdit_power_low.setText(P_sec)
                            # Reactances fillup
                            if line_check[:4] == 'xhl=':
                                X_hl = line_check.replace('xhl=', '')
                                self.transformer.lineEdit_x_hl.clear()
                                self.transformer.lineEdit_x_hl.setText(X_hl)
                            if line_check[:4] == 'xht=':
                                X_ht = line_check.replace('xht=', '')
                                self.transformer.lineEdit_x_ht.clear()
                                self.transformer.lineEdit_x_ht.setText(X_ht)
                            if line_check[:4] == 'xlt=':
                                X_lt = line_check.replace('xlt=', '')
                                self.transformer.lineEdit_x_lt.clear()
                                self.transformer.lineEdit_x_lt.setText(X_lt)
                                # Losses fillup
                            if line_check[:12] == '%noloadloss=':
                                noloadloss = line_check.replace('%noloadloss=', '')
                                self.transformer.lineEdit_losses_no_load.clear()
                                self.transformer.lineEdit_losses_no_load.setText(noloadloss)
                            if line_check[:10] == '%loadloss=':
                                inloadloss = line_check.replace('%loadloss=', '')
                                self.transformer.lineEdit_losses_in_load.clear()
                                self.transformer.lineEdit_losses_in_load.setText(inloadloss)
                            # Main bus fillup
                            if line_check[:7] == 'buses=[':
                                bus = line[ij + 1]
                                bus = bus.split('.')
                                bus = bus[0]
                                self.dlg.lineEdit_name_busbar.clear()
                                self.dlg.lineEdit_name_busbar.setText(bus)
                            # Taps fillup
                            if line_check[:8] == 'numtaps=':
                                taps = line_check.replace('numtaps=', '')
                                self.transformer.lineEdit_no_taps.setText(taps)
                            if line_check[:4] == 'tap=':
                                tap = line_check.replace('tap=', '')
                                self.transformer.lineEdit_tap_position.setText(tap)
                            if line_check[:7] == 'maxtap=':
                                maxtap = line_check.replace('maxtap=', '')
                                self.transformer.lineEdit_max_tap.setText(maxtap)
                            if line_check[:7] == 'mintap=':
                                mintap = line_check.replace('mintap=', '')
                                self.transformer.lineEdit_min_tap.setText(mintap)
                            # Connections fillup
                            if line_check[:7] == 'conns=[':
                                conP = line_check.replace('conns=[', '')
                                if conP == 'wye':
                                    self.transformer.comboBox_conn_high.setCurrentIndex(0)
                                elif conP == 'delta':
                                    self.transformer.comboBox_conn_high.setCurrentIndex(1)

                            if line_check[:7] == 'conns=[':
                                conP = line_check.replace('conns=[', '')
                                if conP == 'wye':
                                    self.transformer.comboBox_conn_high.setCurrentIndex(0)
                                elif conP == 'delta':
                                    self.transformer.comboBox_conn_high.setCurrentIndex(1)
                                conT = line[ij + 2]
                                conS = line[ij + 1]
                                if conT[-1:] == ']':
                                    if conT == 'wye]':
                                        self.transformer.comboBox_conn_tertiary.setCurrentIndex(0)
                                    elif conT == 'delta]':
                                        self.transformer.comboBox_conn_tertiary.setCurrentIndex(1)
                                    if conS == 'wye':
                                        self.transformer.comboBox_conn_low.setCurrentIndex(0)
                                    else:
                                        self.transformer.comboBox_conn_low.setCurrentIndex(1)
                                else:
                                    if conS == 'wye]':
                                        self.transformer.comboBox_conn_low.setCurrentIndex(0)
                                    elif conS == 'delta]':
                                        self.transformer.comboBox_conn_low.setCurrentIndex(1)
                            if line_check[:4] == 'wdg=':
                                if line_check == 'wdg=1':
                                    self.transformer.comboBox_tap_location.setCurrentIndex(0)
                                else:
                                    self.transformer.comboBox_tap_location.setCurrentIndex(1)
                        msg = u'Transformador principal'
                        msg_tr = QCoreApplication.translate('dialog', msg)
                    elif "NOMODEL" in lines[0]:  # substation empty model
                        voltage = line[2]
                        self.dlg.lineEdit_name_busbar.clear()
                        self.dlg.lineEdit_name_busbar.setText(line[0])
                        self.substation = 'None'
                    elif "AUTO" in lines[0]:  # substation as autotransformer
                        self.substation = 'Auto'
                        line = lines[3]
                        line_check = line.split(" ")
                        for ij in range(len(line_check)):
                            if 'kVs=[' in line_check[ij]:
                                # from kVs line to neutral to kVs line to line
                                def_V_prim = line_check[ij].replace('kVs=[', '')
                                def_V_prim = float(def_V_prim)*np.sqrt(3)
                                voltage = str(def_V_prim)
                        self.dlg.lineEdit_name_busbar.clear()
                        txt = 'BUSMV' + file_name + '1'
                        self.dlg.lineEdit_name_busbar.setText(txt)  # first bus
                        msg = u'Autotransformador en subestación'
                        msg_tr = QCoreApplication.translate('dialog', msg)
                    fp.close()
                    break
                else:
                    pass  # no substation
            return voltage
        except Exception:
            self.print_error()
            return 230

    """
    *******************************************************************
    *******************************************************************
    Función firstLine
    Se encarga de la lectura del archivo de salida del azul para poder
    encontrar el nombre de una capa en específico

    -Parámetros de entrada:
    *dir_network (str): directorio donde están los archivos dss
    *file_search (str): nombre del archivo donde se busca la primera linea

    -Valores retornados
    *line (str): nombre de la primera línea en MT
    *******************************************************************
    *******************************************************************
    """

    def firstLine(self, dir_network, file_search = 'LinesMV'):
        try:
            # line = self.dlg.lineEdit_name_busbar.text()
            mainBus = self.dlg.lineEdit_name_busbar.text() + "."
            os.chdir(dir_network)
            line = 0
            for file in glob.glob("*.dss"):
                file_check = re.sub('\.dss$', '', file)
                file_check = file_check[-7:]
                if file_check == file_search:
                    print("mainBus = ", str(mainBus))
                    file_name_path = str(os.getcwd()) + '\\' + '\\' + file
                    fp = open(file_name_path)
                    lines = fp.readlines()
                    for i in lines:
                        if mainBus in i:
                            line = i.split(" ")[1].replace('line.', '')
                            break

                    if line == '':
                        title = u"Error al encontrar primera línea"
                        msg = u"Verificar conexión de subestación"
                        QMessageBox.information(None, QCoreApplication.translate('dialog', title),
                                                QCoreApplication.translate('dialog', msg))
                    break
            return line
        except Exception:
            self.print_error()
            return 0

    """
    *******************************************************************
    *******************************************************************
    Función FindLayer
    Se encarga de la lectura del archivo de salida del azul para poder
    encontrar el nombre de una capa en específico

    -Parámetros de entrada:
    *lines (str list): lista con las líneas del archivo de salida
    del azul
    *exp_find (str): expresión que precede a los nombres de las capas.
    Por ejemplo: "Layers Transformers: "
    *gis_network (str): directorio donde está ubicado el archivo GIS

    -Valores retornados
    *list_names_layers (list): lista con los nombres de los layers
    buscados. Estará vacía si hay errores o si no existe la capa.

    *******************************************************************
    *******************************************************************
    """

    def findLayers(self, lines, exp_find, gis_network):
        try:
            list_names_layers = []
            for line in lines:
                # Búsqueda de nombres de capas
                in_exp = line.find(exp_find)
                if in_exp != -1:  # si encontró la frase anterior entra al if
                    in_exp += len(exp_find)
                    fin_exp = line.find("\n", in_exp)
                    layers_ = line[in_exp:fin_exp]
                    if layers_ != "":  # si existía la capa buscada
                        list_names_layers = layers_.split(",")
                        # se eliminan los espacios en blanco en la lista
                        list_names_layers = list(filter(None, list_names_layers))
                        # Se agrega el path de los archivos gis
                        list_names_layers = [gis_network + "/" + str(i) for i in list_names_layers]
                    break
            return list_names_layers

        except Exception:
            self.print_error()
            return 0

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('ired', message)

    def add_action(self,
                   icon_path,
                   text,
                   callback,
                   enabled_flag=True,
                   add_to_menu=True,
                   add_to_toolbar=True,
                   status_tip=None,
                   whats_this=None,
                   parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/ired/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'IRED'),
            callback=self.run,
            parent=self.iface.mainWindow())

    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&IRED'),
                action)
            self.iface.removeToolBarIcon(action)

    # Función que se encarga de imprimir los errores que han ocurrido
    def print_error(self):
        exc_info = sys.exc_info()
        msg = str(exc_info)
        msg += "\nError: " + str(exc_info)
        msg += "\n********  Información detallada del error **********"
        for tb in traceback.format_tb(sys.exc_info()[2]):
            msg += "\n" + tb

        print(msg)
        return msg

    """
    Función que se encarga de instalar una librería en
    la versión de python de QGIS
    -Parámetros de entrada:
    *library_name (string): nombre de la librería a instalar
    (tal como se le debe pasar a pip)

    -Valores retornados:
    *1 en caso de finalizar exitosamente
    *0 en caso de ocurrir algún error
    """
    def install_libraries(self, library_name):
        try:
            # Se obtiene el path de QGIS
            directorio = str(os.path)
            fin_dir = directorio.find("\\apps")
            first_letter_in = directorio.find(":\\") - 1
            first_letter = directorio[first_letter_in:first_letter_in+1]
            first_letter += ":\\"
            inic_dir = directorio.find(first_letter)
            path = directorio[inic_dir:fin_dir]
            # Se obtiene version de Python en QGIS
            info = sys.version_info
            verspy1 = str(info[0])
            verspy2 = str(info[1])
            carp_python = verspy1 + verspy2
            carp_python = "Python" + carp_python

            # Se copia los archivos
            dir_origen = path + "/bin/"
            name_file_or = "python" + verspy1 + ".dll"
            archivo_origen = str(dir_origen + name_file_or)
            dir_destino = path + "/apps/" + carp_python
            name_dest = dir_destino + "/" + name_file_or

            if os.path.exists(name_dest) is False:
                # Copia python3.dll
                self.copy(archivo_origen, dir_destino)

            # Copia python37.dll
            name_file_or = "python" + verspy1 + verspy2 + ".dll"
            archivo_origen = dir_origen + name_file_or
            name_dest = dir_destino + "/" + name_file_or

            if os.path.exists(name_dest) is False:
                # Copia python37.dll
                self.copy(archivo_origen, dir_destino)

            # Instalación de librerías
            # Actualización de pip
            sentencia = dir_origen + 'python.exe -m pip install –upgrade pip'
            subprocess.call(sentencia, cwd=dir_destino, shell=True)

            # Instalación libreria
            sentencia = dir_origen + "python.exe -m pip install " + library_name
            x = subprocess.call(sentencia, cwd=dir_destino, shell=True)
            print("x = ", x)

            print("Instalación de librería ", library_name, " finalizada.")
            return 1

        except Exception:
            self.print_error()
            return 0

    """
    Función que se encarga de instalar geopandas en QGIS
    -Parámetros de entrada:
    *library_name (string): nombre de la librería a
    instalar (tal como se le debe pasar a pip)

    -Valores retornados:
    *1 en caso de finalizar exitosamente
    *0 en caso de ocurrir algún error
    """

    def install_librerias_extra(self):
        try:
            # Se obtiene el path de QGIS
            directorio = str(os.path)
            fin_dir = directorio.find("\\apps")
            first_letter_in = directorio.find(":\\") - 1
            first_letter = directorio[first_letter_in:first_letter_in+1]
            first_letter += ":\\"
            inic_dir = directorio.find(first_letter)
            path = directorio[inic_dir:fin_dir]
            # Se obtiene version de Python en QGIS
            info = sys.version_info
            verspy1 = str(info[0])
            verspy2 = str(info[1])
            carp_python = verspy1 + verspy2
            carp_python = "Python" + carp_python

            # Se copian los archivos
            dir_origen = path + "/bin/"
            name_file_or = "python" + verspy1 + ".dll"
            archivo_origen = str(dir_origen + name_file_or)
            dir_destino = path + "/apps/" + carp_python
            name_dest = dir_destino + "/" + name_file_or

            if os.path.exists(name_dest) is False:
                # Copia python3.dll
                self.copy(archivo_origen, dir_destino)

            # Copia python37.dll
            name_file_or = "python" + verspy1 + verspy2 + ".dll"
            archivo_origen = dir_origen + name_file_or
            name_dest = dir_destino + "/" + name_file_or

            if os.path.exists(name_dest) is False:
                # Copia python37.dll
                self.copy(archivo_origen, dir_destino)

            # Instalación de librerías
            # Actualización de pip
            sentencia = dir_origen + 'python.exe -m pip install –upgrade pip'
            subprocess.call(sentencia, cwd=dir_destino, shell=True)

            # Instalación librerias
            sentencia = dir_origen + "python.exe -m pip install wheel"
            subprocess.call(sentencia, cwd=dir_destino, shell=True)

            sentencia = dir_origen + "python.exe -m pip install pipwin"
            subprocess.call(sentencia, cwd=dir_destino, shell=True)

            sentencia = dir_origen + "python.exe -m pipwin install numpy"
            subprocess.call(sentencia, cwd=dir_destino, shell=True)

            sentencia = dir_origen + "python.exe -m pipwin install pandas==1.3.5"
            subprocess.call(sentencia, cwd=dir_destino, shell=True)

            sentencia = dir_origen + "python.exe -m pipwin install shapely"
            subprocess.call(sentencia, cwd=dir_destino, shell=True)

            sentencia = dir_origen + "python.exe -m pipwin install gdal"
            subprocess.call(sentencia, cwd=dir_destino, shell=True)

            sentencia = dir_origen + "python.exe -m pipwin install fiona"
            subprocess.call(sentencia, cwd=dir_destino, shell=True)

            sentencia = dir_origen + "python.exe -m pipwin install pyproj"
            subprocess.call(sentencia, cwd=dir_destino, shell=True)

            sentencia = dir_origen + "python.exe -m pipwin install six"
            subprocess.call(sentencia, cwd=dir_destino, shell=True)

            sentencia = dir_origen + "python.exe -m pipwin install rtree"
            subprocess.call(sentencia, cwd=dir_destino, shell=True)

            # sentencia = dir_origen + "python.exe -m pipwin install geopandas"
            # x = subprocess.call(sentencia, cwd=dir_destino, shell=True)
            
            sentencia = dir_origen + "python.exe -m pipwin install openpyxl"
            x = subprocess.call(sentencia, cwd=dir_destino, shell=True)
            
            print(" x = ", x)

            print("Instalación de librerías finalizada.")
            return 1

        except Exception:
            self.print_error()
            return 0


    """
    Function AttributeTable_ToDataframe
    Convert an attribute table into a dataframe
    Entries:
    *layer_name (str): layer's name

    Outputs:
    *df_at_table (dataframe): dataframe with all the information
    of the attribute table.
    """

    def AttributeTable_ToDataframe(self, layer_name):
        try:
            layer_name = layer_name.split("/")[-1]
            layer = QgsProject.instance().mapLayersByName(layer_name)[0]
            features = layer.getFeatures()
            col_names = layer.dataProvider().fields().names()

            # Use list comprehension to create a list of feature attributes
            attributes_list = [feature.attributes() for feature in features]

            # Create a DataFrame using the list of attributes
            df_att_table = pd.DataFrame(attributes_list, columns=col_names)

            # Replace 'NULL' and NULL values with None
            df_att_table.replace(['NULL', None], np.nan, inplace=True)

            # Replace empty strings with NaN
            df_att_table.replace(r'^\s*$', np.nan, regex=True, inplace=True)

            # Reset index
            df_att_table.reset_index(inplace=True)

            return df_att_table, layer
        except Exception:
            self.print_error()
            return pd.DataFrame(), 0

    """
    Function save_dataframe
    Función que guarda un dataframe en capas
    Entries:
    *df (dataframe): dataframe con los datos a guardar
    *layer (QgsVectorLayer): layer donde se van a escribir los datos
    *col_new (str): nombre de la columna donde se va a guardar el
    resultado en capas. Si no se indica será aquella columna que
    exista en el dataframe y no en las capas.

    Outputs:
    *1 si finaliza exitosamente, 0 caso contrario
    """

    def save_dataframe(self, df, layer, col_new=""):
        try:
            features = layer.getFeatures()

            if not col_new:
                layer_columns = layer.dataProvider().fields().names()
                dataframe_columns = list(df.columns)
                col_new = list(set(dataframe_columns) - set(layer_columns))

            layer.startEditing()

            # Check if the column already exists
            attribute_index = layer.fields().indexFromName(col_new)

            # If it doesn't exist, create it
            if attribute_index == -1:
                new_field = QgsField(col_new, QVariant.Double)
                layer.dataProvider().addAttributes([new_field])
                layer.updateFields()
                attribute_index = layer.fields().indexFromName(col_new)

            df.reset_index(inplace=True, drop=True)

            # Collecting indices of the layer
            layer_indices = [feature.id() for feature in features]
               
            for index in layer_indices:
                # Set the column's value to None for each feature
                layer.changeAttributeValue(index, attribute_index, None)

            for index, row in df.iterrows():
                # Only updating values for indices present in the layer
                if index in layer_indices:
                    value = float(row[col_new])
                    layer.changeAttributeValue(index, attribute_index, value)
                    

            layer.commitChanges()
            return 1

        except Exception:
            self.print_error()
            return 0



    # Master.dss file creation
    def create_master(self, dir_network, name_file_created,
                      tx_active, volt_nom):
        try:
            name_circuit = name_file_created.split('_')[0]
            volt_nom = str(volt_nom)
            created_files = open(dir_network + '/' + name_file_created + '.dss', 'r')
            created_files = created_files.read()

            if tx_active is False:
                wrd1 = 'redirect ' + name_file_created.split('_')[0] + '_Substation.dss'
                created_files = created_files.replace(wrd1, '')
            
            firstLine = 'MV3P' + name_circuit + '00'
            
            file = open(dir_network + '/Master.dss', 'w')
            file.write('set defaultbasefrequency=60\n')
            # Datos de cortocircuito
            three_phase_SC = self.dlg.lineEdit_3pShortCircuitPower.text()
            if not three_phase_SC:
                three_phase_SC = 10  # def_3pSCP_nom
            single_phase_SC = self.dlg.lineEdit_1pShortCircuitPower.text()
            if not single_phase_SC:
                single_phase_SC = 10.5  # def_1pSCP_nom
            # Tensión nominal revisar

            if self.dlg.SCMVA.isChecked():  # SC MVAs
                nw_line = 'Edit Vsource.Source BasekV=' + volt_nom
                nw_line += ' pu=1.00 angle=0'
                nw_line += ' frequency=60 phases=3 MVAsc3='
                nw_line += three_phase_SC + ' MVAsc1=' + single_phase_SC + '\n'
                file.write(nw_line)
            if self.dlg.SCkA.isChecked():  # SC kAs
                nw_line = 'Edit Vsource.Source BasekV=' + volt_nom
                nw_line += ' pu=1.00 angle=0'
                nw_line += ' frequency=60 phases=3 Isc3='
                nw_line += str(float(three_phase_SC)* 1000)+ ' Isc1=' 
                nw_line += str(float(single_phase_SC)* 1000)+ '\n'
                file.write(nw_line)
            file.write(created_files + '\n')
            file.close()
            return firstLine
        except Exception:
            self.print_error()
            return ""

    """
    Function to change the column names of a dataframe: delete the 
    spaces, special characters and convert all the names to uppercase
    
    Entries:
    *df (dataframe): dataframe to convert names
    
    Output:
    *df (dataframe): dataframe with the column names converted
    """
    
    def change_columnnames(self, df):
        from unidecode import unidecode
        x = [c.upper() for c in df.columns]
        # se eliminan los espacios en los nombres de las columnas
        # en los datos reportados
        x = [c.upper() for c in x]
        x = [unidecode(c) for c in x]
        x = [c.replace(' ', '_') for c in x]
        x = [c.replace('\n', '_') for c in x]
        df.columns = x
        return df
        
    """
    Función categ_layer
    Se encarga de la categorización de una una capa tipo línea en QGIS
    Para realiza las particiones en 10 categorías distribuyéndolas entre
    el valor mínimo y máximo en la columna indicada

    Valores de entrada:
    *df (dataframe): dataframe con los datos a categorizar
    *layer (QgsVectorLayer): capa en la que se va a realizar la categorizacion
    *column_name (str): nombre de la columna que se va a categorizar

    Valores retornados:
    *1 si finaliza exitosamente, 0 si hay errores

    """
   
    
    def assign_color(self, index):
        color_map = matplotlib.colors.LinearSegmentedColormap.from_list("", ["red","yellow","green"])
        rgb = color_map(index / 5)[:3]  # Normalize index with the number of color steps (5 here). 
        return matplotlib.colors.rgb2hex(rgb)
   
    def categ_layer(self, df, layer, column_name, ranges=None):
        try:
            idx_col = layer.fields().indexFromName(column_name)
            if idx_col == -1:
                print(f"No se encontró la columna {column_name} por lo que no se realizará la categorización")
                return 0

            max_ = df.loc[df[column_name].idxmax(), column_name]
            min_ = df.loc[df[column_name].idxmin(), column_name]
            max_, min_ = float(max_), float(min_)

            symbol = QgsLineSymbol.defaultSymbol(layer.geometryType())
            symbol.setWidth(1.6)

            if min_ < 0:
                print("No deben existir valores negativos")
                return 0

            if max_ == min_:
                print("El máximo y mínimo es el mismo, se pintará todo de un color")
                symbol.setColor(QColor(self.assign_color(5)))  # using the last color of the gradient
                symbol.setWidth(1.6)
                rng = QgsRendererRange(min_, max_, symbol, f"{round(min_, 2)}-{round(max_, 2)}")
                renderer = QgsGraduatedSymbolRenderer(column_name, [rng])

            else:
                div = 6
                step = (max_ - min_) / div

                name_cat = []
                rang_ = [min_]
                last = min_
                while last < max_:
                    last += step
                    name_cat.append(f"{round(last - step, 2)}-{round(last, 2)}")
                    rang_.append(last)

                epsilon = 1
                values = [(rng.label(), rng.lowerValue(), rng.upperValue() + epsilon if i == div - 1 else rng.upperValue(), self.assign_color(i), 1.6) for i, rng in enumerate(ranges)] if ranges else [(name, lower, upper + epsilon if i == div - 1 else upper, self.assign_color(i), 1.6) for i, (name, lower, upper) in enumerate(zip(name_cat, rang_, rang_[1:]))]

                ranges = []
                for label, lower, upper, color, _ in values:
                    symbol = QgsLineSymbol.defaultSymbol(layer.geometryType())
                    symbol.setColor(QColor(color))
                    symbol.setWidth(1.6)
                    rng = QgsRendererRange(lower, upper, symbol, label)
                    ranges.append(rng)

                renderer = QgsGraduatedSymbolRenderer(column_name, ranges)

            layer.setRenderer(renderer)
            iface.mapCanvas().refresh()
            layer.triggerRepaint()
            return ranges

        except KeyError:
            return 1
        except Exception as e:
            print(f"Error: {e}")
            return 0

    # ##################################################################
    def run(self):
        try:
            self.protections = False
            self.rec_fus = False
            
            self.install_libraries("networkx==3.1")
            self.install_libraries("pandas==1.3.5")
            try:
                import comtypes.client as cc
            except:
                self.install_libraries("comtypes")
                print("Instalando comtypes")
            import comtypes.client as cc
            try:
                from unidecode import unidecode
            except Exception:
                self.install_libraries("Unidecode")
                from unidecode import unidecode
            try:
                from openpyxl import openpyxl
            except Exception:
                self.install_libraries("openpyxl")
                import openpyxl
            
            # try:
                # import numpy as np
                # import gdal
                # import fiona
                # import pyproj
                # import six
                # import rtre
            
            # except Exception:
                # self.install_librerias_extra()

            """Run method that performs all the real work"""
            # Se busca información general sobre estructura de las carpetas
            prjpath, dir_general, dir_network = self.circuit_calling()
            if prjpath == 0:
                return
            # Direcctorio de carpeta GIS
            gis_network = dir_general + "/GIS"

            # Se busca el archivo salida del azul
            name_file_created = ""
            self.dlg.lineEdit_dirOutput.clear()
            self.dlg.lineEdit_dirOutput.setText(dir_general)
            os.chdir(dir_network)

            files_names = list(glob.glob(os.path.join(dir_network, '*.dss')))
            for file in files_names:
                if len(file.split('\\')[1].split('.')[0].split('_')) > 1:
                    if file.split('\\')[1].split('.')[0].split('_')[1] == 'OutputQGIS2OpenDSS':
                        name_file_created = file.split('\\')[1].split('.')[0]

            if name_file_created == "":
                msg = "Debe existir el archivo de salida de QGIS2OpenDSS "
                msg += "para poder ejecutar el programa correctamente"
                title = "Error al encontrar salida de QGIS2OpenDSS"
                QMessageBox.information(None, title, msg)
                return None

            # Verifica si hay cargas de BT
            dir_profiles = os.path.join(dir_network,
                                        'profiles')
            self.cargas = False
            name_output_azul = dir_network + "/" + name_file_created + ".dss"
            with open(name_output_azul, "r") as f:
                lines = f.readlines()
                for line in lines:
                    linea_ = line.lower()
                    # averigua el nombre del archivo de cargas
                    if "loadslv" in linea_ and linea_[0] != "!":  
                        name_lvloads = line.replace("redirect ", "")
                        self.cargas = True
                    if "loadsmv" in linea_ and linea_[0] != "!":
                        name_mvloads = line.replace("redirect ", "")
                        self.cargas = True
            if self.cargas is True:
                load_profiles = auxfcns.ReadLoadProfiles(self, dir_profiles,
                                                         dir_network,
                                                         name_file_created)
            
            # Se buscan características del circuito en salida del azul
            volt_nom = self.cktNameDefaults(dir_general, dir_network)
            circname_azul = name_file_created.split("_")[0]

            # Valores por defecto
            phase_angle = 0
            frequency = 60

            # Se buscan los nombres de las capas
            file_ = dir_network + "/" + name_file_created + ".dss"
            with open(file_, "r") as f:
                lines = f.readlines()

            # Diccionario con las expresiones buscadas según la capa
            searched_expressions = {'Subestacion': "!Layer Substation: ",
                                    'LineasMT_sub': "Layers LinesMV_sub: ",
                                    'LineasMT_aer': "!Layers LinesMV_aer: ",
                                    'CargasMT': "!Layers LoadsMV: ",
                                    'Trafos': "!Layers Transformers: ",
                                    'LineasBT_sub': "!Layers LinesLV_sub: ",
                                    'LineasBT_aer': "!Layers LinesLV_aer: ",
                                    'Acometidas': "!Layers Acometidas: ",
                                    'CargasBT': "!Layers LoadsLV: ",
                                    'Regs': "!Layer Regulators: ",
                                    'Reclosers': "!Layer Reclosers: ",
                                    'Fuses': "!Layer Fuses: ",
                                    'Seccionadores': "!Layer Switches: ",
                                    'Capacitors': "!Layer Capacitors: ",
                                    'DERss': "!Layers DERss: ",
                                    'DERls': "!Layers DERls: "
                                    }

            # Nombre de capa de subestación
            sub_exp = searched_expressions['Subestacion']
            layer_sub = self.findLayers(lines, sub_exp, gis_network)

            # MV Lines
            # IT'S NECESSARY TO MANTAIN THE ORIGINAL FILES IN ORDER TO UPDATE THE FILES AT THE END
            # Líneas MT aéreas
            exp_search = searched_expressions['LineasMT_aer']
            layer_mt_aer = self.findLayers(lines, exp_search, gis_network)

            # Líneas MT sub
            exp_search = searched_expressions['LineasMT_sub']
            layer_mt_sub = self.findLayers(lines, exp_search, gis_network)

            # LV lines
            vect_lv = []
            # Aéreas
            exp_search = searched_expressions['LineasBT_aer']
            layer_l_oh_lv = self.findLayers(lines, exp_search, gis_network)
            
            # Subterráneas
            exp_search = searched_expressions['LineasBT_sub']
            layer_l_ug_lv = self.findLayers(lines, exp_search, gis_network)

            # Acometidas
            exp_search = searched_expressions['Acometidas']
            layer_acom = self.findLayers(lines, exp_search, gis_network)

            # TX info
            exp_search = searched_expressions['Trafos']
            layer_tx = self.findLayers(lines, exp_search, gis_network)

            #Reguladores
            exp_search = searched_expressions['Regs']
            layer_reg = self.findLayers(lines, exp_search, gis_network)
            
            #Capacitores
            exp_search = searched_expressions['Capacitors']
            layer_cap = self.findLayers(lines, exp_search, gis_network)
            
            # Loads info
            # BT
            exp_search = searched_expressions['CargasBT']
            layer_load_bt = self.findLayers(lines, exp_search, gis_network)
            
            # MT
            exp_search = searched_expressions['CargasMT']
            layer_mt_loads = self.findLayers(lines, exp_search, gis_network)
            
            # Pdevice info
            # Fusibles
            exp_search = searched_expressions['Fuses']
            layer_fuses = self.findLayers(lines, exp_search, gis_network)
            
            # Reconectadores
            exp_search = searched_expressions['Reclosers']
            layer_rec = self.findLayers(lines, exp_search, gis_network)
            
            # DERs Existentes
            # DER pequeña escala
            exp_search = searched_expressions['DERss']
            layer_der_ss = self.findLayers(lines, exp_search, gis_network)
            
            # DER gran escala
            exp_search = searched_expressions['DERls']
            layer_der_ls = self.findLayers(lines, exp_search, gis_network)
            
            # Banderas para habilitar los estudios de protecciones
            if ((layer_rec != []) or (layer_rec != 0) or (layer_fuses != []) or (layer_fuses != 0)):
                self.protections = True
            if ((layer_rec != []) and (layer_rec != 0) and (layer_fuses != []) and (layer_fuses != 0)):
                self.rec_fus = True
            self.enabler_protection_analysis()
            

            # ######################################################################
            # ######################################################################
            # ######################################################################
            # ######################################################################
            # Create the dialog with elements (after translation) and keep reference
            # Only create GUI ONCE in callback, so that it will only load when the plugin is started
            # show the dialog
            self.dlg.show()
            self.msg_final = ""
            # Run the dialog event loop
            result = self.dlg.exec_()
            # See if OK was pressed
            if result:
                start_lectura_capas = time.time()
                
                self.output = self.dlg.lineEdit_dirOutput.text()
                
                # Nombre de capa de subestación
                if layer_sub == [] or layer_sub == 0:
                    msg = "Debe existir la capa de subestación/cabecera del alimentador "
                    msg += "para poder ejecutar el programa correctamente"
                    title = "Error al encontrar capa"
                    QMessageBox.information(None, title, msg)
                    return None
                else:
                    try:
                        subs, sub_layer = self.AttributeTable_ToDataframe(layer_sub[0])
                        # subs = gp.read_file(layer_sub[0] + ".shp")
                    except DriverError:
                        msg = "El nombre del archivo shp de la capa de "
                        msg += "subestación debe ser igual al nombre de la capa"
                        title = "Error al encontrar capa"
                        QMessageBox.information(None, title, msg)
                        return None
                    try:
                        assert ("XHL" not in subs.columns)
                    except AssertionError:
                        msg = "La capa de cabecera que está utilizando corresponde a una capa de subestación. \n"
                        msg += "Favor volver a correr el plugin QGIS2OPENDSS sin modelar la subestación"
                        title = "Error de atributos en la cabecera"
                        QMessageBox.information(None, title, msg)
                        return None
                    try:
                        assert (("ISC_3P" in subs.columns) and ("ISC_1P" in subs.columns))
                    except AssertionError:
                        msg = "La capa de cabecera que está utilizando no posee los atributos de medición de cortocircuito. \n"
                        msg += "Favor corregir"
                        title = "Error de atributos en la cabecera"
                        QMessageBox.information(None, title, msg)
                        return None
                    try:
                        assert ((subs.loc[0,"ISC_3P"] not in ["", " ", None, "NULL"]) and (subs.loc[0,"ISC_1P"] not in ["", " ", None, "NULL"]))
                    except AssertionError:
                        msg = "La capa de cabecera que está utilizando no posee valores válidos en los atributos de medición de cortocircuito. \n"
                        msg += "Favor corregir"
                        title = "Error de atributos en la cabecera"
                        QMessageBox.information(None, title, msg)
                        return None

                # Capas de buses MV (estas siempre tendrán el mismo nombre)
                try:
                    nodes_mv, layer_mt_buses = self.AttributeTable_ToDataframe("/Bus_MT_Layer")
                    rand_bus = nodes_mv.loc[0,'BUS']
                    ckt_name = rand_bus.split(rand_bus[min([i for i, c in enumerate(rand_bus) if c.isdigit()])])[0].split('BUSMV')[1]
                    # Cambio de nombre al primer nodo:
                    nodes_mv.loc[nodes_mv['BUS'].isin(['BUSMV'+ckt_name+'1', 'Sourcebus']), 'BUS'] = 'AFTERMETER'
                    # nodes_mv = gp.read_file(gis_network + '/Bus_MT_Layer.shp')
                except DriverError:
                    msg = "Verifique que existan las capas de nodos de "
                    msg += "media tensión"
                    title = "Error al encontrar capa"
                    QMessageBox.information(None, title, msg)
                    return None

                # Capas de buses LV (estas siempre tendrán el mismo nombre)
                try:
                    nodes_lv, layer_bt_buses = self.AttributeTable_ToDataframe("/Bus_BT_Layer")
                    # nodes_lv = gp.read_file(gis_network + '/Bus_BT_Layer.shp')
                    lv_groups = pd.DataFrame(list(nodes_lv['GROUP']),
                                             index=nodes_lv['BUS'],
                                             columns=['LV_GROUP'])
                except Exception:
                    nodes_lv = pd.DataFrame()
                    lv_groups = pd.DataFrame()

                # MV Lines
                # IT'S NECESSARY TO MANTAIN THE ORIGINAL FILES IN ORDER TO UPDATE THE FILES AT THE END
                # Líneas MT aéreas
                
                dist_max_mt_aer = -1
                dist_max_mt_sub = -1
                if layer_mt_aer == [] or layer_mt_aer == 0:
                    lines_mv_oh_layer_original = pd.DataFrame()
                    lines_mv_oh_layer = lines_mv_oh_layer_original.copy()
                else:
                    try:
                        lines_mv_oh_layer_original, layer_mv_oh = self.AttributeTable_ToDataframe(layer_mt_aer[0])
                        columna = "length"
                        idx_lenght = layer_mv_oh.fields().indexFromName(columna)
                        if idx_lenght == -1:
                            columna = "LENGTH"
                            idx_lenght = layer_mv_oh.fields().indexFromName(columna)
                            if idx_lenght == -1:
                                msg = "Debe introducir el atributo " + columna
                                msg += " en la capa de líneas aérea de MT"
                                title = "Error"
                                QMessageBox.information(None, title, msg)
                                return None
                        dist_max_mt_aer = float(layer_mv_oh.maximumValue(idx_lenght))
                        # lines_mv_oh_layer_original = gp.read_file(layer_mt_aer[0] + ".dbf")
                        lines_mv_oh_layer = lines_mv_oh_layer_original.copy()
                        lines_mv_oh_layer['bus2'] = lines_mv_oh_layer['bus2'].str.replace('_swt', '')
                        lines_mv_oh_layer['bus1'] = lines_mv_oh_layer['bus1'].str.replace('_reg', '')
                    except DriverError:
                        lines_mv_oh_layer_original = pd.DataFrame()
                        lines_mv_oh_layer = lines_mv_oh_layer_original.copy()
                        msg = "El nombre del archivo shp de la capa de "
                        msg += "líneas MT aéreas  debe ser igual al nombre de la capa"
                        title = "Error al encontrar capa"
                        QMessageBox.information(None, title, msg)
                        return None
                # Líneas MT sub
                if layer_mt_sub == [] or layer_mt_sub == 0:
                    lines_mv_ug_layer_original = pd.DataFrame()
                    lines_mv_ug_layer = lines_mv_ug_layer_original.copy()
                else:
                    try:
                        lines_mv_ug_layer_original, layer_mv_ug = self.AttributeTable_ToDataframe(layer_mt_sub[0])
                        columna = "length"
                        idx_lenght = layer_mv_ug.fields().indexFromName(columna)
                        if idx_lenght == -1:
                            columna = "LENGTH"
                            idx_lenght = layer_mv_ug.fields().indexFromName(columna)
                            if idx_lenght == -1:
                                msg = "Debe introducir el atributo " + columna
                                msg += " en la capa de líneas aérea de MT"
                                title = "Error"
                                QMessageBox.information(None, title, msg)
                                return None
                        dist_max_mt_sub = float(layer_mv_ug.maximumValue(idx_lenght))
                        # lines_mv_ug_layer_original = gp.read_file(layer_mt_sub[0] + ".dbf")
                        lines_mv_ug_layer = lines_mv_ug_layer_original.copy()
                        lines_mv_ug_layer['bus2'] = lines_mv_ug_layer['bus2'].str.replace('_swt', '')
                    except DriverError:
                        lines_mv_ug_layer_original = pd.DataFrame()
                        lines_mv_ug_layer = lines_mv_ug_layer_original.copy()
                        msg = "El nombre del archivo shp de la capa de "
                        msg += "líneas MT subterráneas debe ser igual al nombre de la capa"
                        title = "Error al encontrar capa"
                        QMessageBox.information(None, title, msg)
                        return None

                if lines_mv_oh_layer_original.empty and lines_mv_ug_layer_original.empty:
                    msg = "Debe existir la capa de líneas de media tensión "
                    msg += "para poder ejecutar el programa correctamente"
                    title = "Error al encontrar capa"
                    QMessageBox.information(None, title, msg)
                    return None

                # Union capas de líneas
                lines_mv = pd.concat([lines_mv_oh_layer, lines_mv_ug_layer],
                                     sort=True)
                lines_mv.index = range(len(lines_mv.index))
                drp_ls = lines_mv.loc[lines_mv['DSSNAME'].isnull()].index.values
                lines_mv = lines_mv.loc[(lines_mv.DSSNAME != NULL), :]
                lines_mv = lines_mv.loc[(lines_mv.DSSNAME != ""), :]
                lines_mv = lines_mv.drop(drp_ls)
                lines_mv.index = range(len(lines_mv.index))
                
                # Distancia entre puntos de instalacion
                fixed_distance = self.dlg.distance_ls.value()*1000
                print("fixed_distance =", fixed_distance)
                
                """
                Distancia entre puntos de instalación
                Debe ser mayor a la distancia más larga
                """
                dist_max = max(dist_max_mt_aer, dist_max_mt_sub)
                if fixed_distance < dist_max:
                    fixed_distance = math.floor(round(dist_max, 2))
                    msg = "La distancia entre puntos de instalación seleccionada"
                    msg += " es menor a la longitud de la línea de MT con mayor longitud"
                    msg += "\nSe simulará con la longitud de la mayor "
                    msg += "línea de MT: " + str(fixed_distance)
                    title = "Error"
                    QMessageBox.information(None, title, msg)

                # LV lines
                vect_lv = []
                # Aéreas
                if layer_l_oh_lv == [] or layer_l_oh_lv == 0:
                    lines_lv_oh_layer = pd.DataFrame()
                else:
                    try:
                        lines_lv_oh_layer, layer_lv_oh = self.AttributeTable_ToDataframe(layer_l_oh_lv[0])
                        lines_lv_oh_layer['LV_GROUP'] = lines_lv_oh_layer['LV_GROUP'].astype(float)
                        # lines_lv_oh_layer = gp.read_file(layer[0] + ".shp")
                    except DriverError:
                        lines_lv_oh_layer = pd.DataFrame()
                        msg = "El nombre del archivo shp de la capa de "
                        msg += "líneas BT aéreas debe ser igual al nombre de la capa"
                        title = "Error al encontrar capa"
                        QMessageBox.information(None, title, msg)
                        return None

                vect_lv.append(lines_lv_oh_layer)
                # Subterráneas
                if layer_l_ug_lv == [] or layer_l_ug_lv == 0:
                    lines_lv_ug_layer = pd.DataFrame()
                else:
                    try:
                        lines_lv_ug_layer, layer_lv_ug = self.AttributeTable_ToDataframe(layer_l_ug_lv[0])
                        lines_lv_ug_layer['LV_GROUP'] = lines_lv_ug_layer['LV_GROUP'].astype(float)
                        # lines_lv_ug_layer = gp.read_file(layer[0] + ".shp")
                    except DriverError:
                        lines_lv_ug_layer = pd.DataFrame()
                        msg = "El nombre del archivo shp de la capa de "
                        msg += "líneas BT aéreas debe ser igual al nombre de la capa"
                        title = "Error al encontrar capa"
                        QMessageBox.information(None, title, msg)
                        return None

                vect_lv.append(lines_lv_ug_layer)
                if lines_lv_oh_layer.empty and lines_lv_ug_layer.empty:
                    msg = "Debe existir la capa de líneas de baja tensión "
                    msg += "para poder ejecutar el programa correctamente"
                    title = "Error al encontrar capa"
                    # QMessageBox.information(None, title, msg)
                    # return
                
                # Acometidas
                if layer_acom == [] or layer_acom == 0:
                    acom = pd.DataFrame()
                else:
                    try:
                        for name_shape in layer_acom:
                            acom, layer_ac = self.AttributeTable_ToDataframe(name_shape)
                            acom['LV_GROUP'] = acom['LV_GROUP'].astype(float)
                            # acom = gp.read_file(name_shape + ".shp")
                            vect_lv.append(acom)
                    except DriverError:
                        msg = "El nombre del archivo shp de la capa de "
                        msg += "acometidas debe ser igual al nombre de la capa"
                        title = "Error al encontrar capa"
                        QMessageBox.information(None, title, msg)
                        return None

                # union capas de líneas
                lines_lv = pd.concat(vect_lv, sort=True)
                lines_lv.index = range(len(lines_lv.index))
                if lines_lv.empty is False:
                    try:
                        line_lv_groups = pd.DataFrame(list(lines_lv['LV_GROUP']),
                                                      index=lines_lv['DSSNAME'].astype(str),
                                                      columns=['LV_GROUP'])
                    except Exception:
                        self.print_error()
                        line_lv_groups = pd.DataFrame(list(lines_lv['LV_GROUP']),
                                                      index=lines_lv['DSSNAME'].astype(str),
                                                      columns=['LV_GROUP'])
                else:
                    line_lv_groups = pd.DataFrame()

                # TX layers
                if layer_tx == [] or layer_tx == 0:
                    msg = "Debe existir la capa de transformadores "
                    msg += "para poder ejecutar el programa correctamente"
                    title = "Error al encontrar capa"
                    QMessageBox.information(None, title, msg)
                    return
                try:
                    vect_traf = []
                    for name_shape in layer_tx:
                        tx_layer, layer_trafos = self.AttributeTable_ToDataframe(name_shape)
                        # tx_layer = gp.read_file(name_shape + ".shp")
                        vect_traf.append(tx_layer)
                    tx_layer = pd.concat(vect_traf, sort=True)
                    tx_layer = tx_layer.drop(tx_layer.loc[tx_layer['DSSNAME'].isnull()].index.values)
                    tx_layer['LV_GROUP'] = tx_layer['LV_GROUP'].astype(float)
                except DriverError:
                    msg = "El nombre del archivo shp de la capa de "
                    msg += "transformadores debe ser igual al nombre de la capa"
                    title = "Error al encontrar capa"
                    QMessageBox.information(None, title, msg)
                    return None

                try:
                    tx_groups = pd.DataFrame(list(tx_layer['LV_GROUP']),
                                             index=tx_layer['DSSNAME'],
                                             columns=['LV_GROUP'])
                except Exception:
                    self.print_error()
                    tx_groups = pd.DataFrame(list(tx_layer['LV_GROUP']),
                                             index=tx_layer['DSSNAME'],
                                             columns=['LV_GROUP'])
                
                # REGULADORES DE TENSIÓN
                if layer_reg == [] or layer_reg == 0:
                    cols_reg = ['BUSINST', 'VREG', 'BANDWIDTH']
                    regs = pd.DataFrame(np.nan, columns=cols_reg, index=[])
                else:
                    try:
                        regs, layer_regs = self.AttributeTable_ToDataframe(layer_reg[0])
                        cols_reg = ['BUSINST', 'VREG', 'BANDWIDTH']
                        regs = regs[cols_reg]
                    
                    except DriverError:
                        cols_reg = ['BUSINST', 'VREG', 'BANDWIDTH']
                        regs = pd.DataFrame(np.nan, columns=cols_reg, index=[])
                        msg = "El nombre del archivo shp de la capa de "
                        msg += "reguladores de tensión debe ser igual al nombre de la capa"
                        title = "Error al encontrar capa"
                        QMessageBox.information(None, title, msg)
                        return None
                
                # CAPACITORES
                if layer_cap == [] or layer_cap == 0:
                    cols_cap = ["BUSINST", "OBJMAX", "OBJMIN"]
                    caps = pd.DataFrame()
                else:
                    try:
                        caps, layer_caps = self.AttributeTable_ToDataframe(layer_cap[0])
                        # Filtrar por los capacitores que únicamente son para controlar tensión
                        caps = caps[caps["CONTROL"]== "V"].loc[:,["BUSINST", "OBJ_MAX", "OBJ_MIN"]]

                    except DriverError:
                        caps = pd.DataFrame(np.nan, columns=["BUSINST", "OBJ_MAX", "OBJ_MIN"], index=[])
                        msg = "El nombre del archivo shp de la capa de "
                        msg += "capacitores debe ser igual al nombre de la capa"
                        title = "Error al encontrar capa"
                        QMessageBox.information(None, title, msg)
                        return None

                # Loads info
                # BT
                if layer_load_bt == [] or layer_load_bt == 0:
                    lv_loads_layer = pd.DataFrame()
                else:
                    try:
                        vect_loads = []
                        for name_shape in layer_load_bt:
                            lv_loads_layer, layer_loads_lv = self.AttributeTable_ToDataframe(name_shape)
                            lv_loads_layer['LV_GROUP'] = lv_loads_layer['LV_GROUP'].astype(float)
                            # lv_loads_layer = gp.read_file(name_shape + ".shp")
                            vect_loads.append(lv_loads_layer)
                        lv_loads_layer = pd.concat(vect_loads, sort=True)

                    except DriverError:
                        lv_loads_layer = pd.DataFrame()
                        msg = "El nombre del archivo shp de la capa de "
                        msg += "cargas de BT debe ser igual al nombre de la capa"
                        title = "Error al encontrar capa"
                        QMessageBox.information(None, title, msg)
                        return None

                # MT
                if layer_mt_loads == [] or layer_mt_loads == 0:
                    mv_loads_layer = pd.DataFrame()
                else:
                    try:
                        vect_loads = []
                        for name_shape in layer_mt_loads:
                            mv_loads_layer, layer_mv_loads = self.AttributeTable_ToDataframe(name_shape)
                            # mv_loads_layer = gp.read_file(name_shape + ".shp")
                            vect_loads.append(mv_loads_layer)
                        mv_loads_layer = pd.concat(vect_loads, sort=True)
                    except DriverError:
                        mv_loads_layer = pd.DataFrame()
                        msg = "El nombre del archivo shp de la capa de "
                        msg += "cargas de MT debe ser igual al nombre de la capa"
                        title = "Error al encontrar capa"
                        QMessageBox.information(None, title, msg)
                        return None

                # Tienen que haber cargas de baja o de media
                if (mv_loads_layer.empty is True
                     and lv_loads_layer.empty is True):
                        msg = "Para poder ejecutar la herramienta "
                        msg += "deben existir cargas de media o baja "
                        msg += "tensión"
                        title = "Error al encontrar capas"
                        QMessageBox.information(None, title, msg)
                        return None

                # Pdevice info
                # Fusibles

                if layer_fuses == [] or layer_fuses == 0:
                    cols = ['PHASEDESIG', 'NC', 'OPERATINGV',  'bus1',
                            'bus2', 'DSSNAME', 'MV_GROUP', 'HC',
                            'SAVE','COORDINATE', 'geometry']
                    fuse_layer = pd.DataFrame(np.nan, columns=cols,
                                              index=[])
                else:
                    try:
                        fuse_layer, layer_fuse = self.AttributeTable_ToDataframe(layer_fuses[0])
                        # fuse_layer = gp.read_file(layer[0] + ".shp")
                        fuse_layer['HC'] = fuse_layer['HC'].apply(lambda x:
                                                                  unidecode(str(x)).strip().upper())
                        exp = (fuse_layer['HC'] == 'SI') | (fuse_layer['HC'] == 'YES')
                        fuse_layer = fuse_layer.loc[exp]
                        fuse_layer['bus1'] = fuse_layer['bus1'].str.replace('_swt', '')
                        fuse_layer['bus2'] = fuse_layer['bus2'].str.replace('_swt', '')
                    except DriverError:
                        cols = ['PHASEDESIG', 'NC', 'OPERATINGV',  'bus1',
                                'bus2', 'DSSNAME', 'MV_GROUP', 'HC',
                                'SAVE','COORDINATE', 'geometry']
                        fuse_layer = pd.DataFrame(np.nan, columns=cols,
                                                  index=[])
                        msg = "El nombre del archivo shp de la capa de "
                        msg += "fusibles debe ser igual al nombre de la capa"
                        title = "Error al encontrar capa"
                        QMessageBox.information(None, title, msg)
                        return None
                    except KeyError:
                        cols = ['PHASEDESIG', 'NC', 'OPERATINGV',  'bus1',
                                'bus2', 'DSSNAME', 'MV_GROUP', 'HC',
                                'SAVE','COORDINATE', 'geometry']
                        fuse_layer = pd.DataFrame(np.nan, columns=cols,
                                                  index=[])

                # Reconectadores
                cols_rec = ['NOMVOLT','PHASEDESIG', 'NOMINALVOL',
                            'NC', 'HC', 'bus1', 'bus2', 'DSSNAME',
                            'MV_GROUP']
                if layer_rec == [] or layer_rec == 0:
                    recloser_layer = pd.DataFrame(np.nan, columns=cols_rec,
                                                  index=[])
                else:
                    try:
                        recloser_layer, layer_reclosers = self.AttributeTable_ToDataframe(layer_rec[0])
                        # recloser_layer = gp.read_file(layer[0] + ".shp")
                        recloser_layer['HC'] = recloser_layer['HC'].apply(lambda x:
                                                                          unidecode(str(x)).strip().upper())
                        exp = (recloser_layer['HC'] == 'SI') | (recloser_layer['HC'] == 'YES')
                        recloser_layer = recloser_layer.loc[exp]
                        recloser_layer['bus1'] = recloser_layer['bus1'].str.replace('_swt', '')
                        recloser_layer['bus2'] = recloser_layer['bus2'].str.replace('_swt', '')
                    except DriverError:
                        recloser_layer = pd.DataFrame(np.nan, columns=cols_rec,
                                                      index=[])
                        msg = "El nombre del archivo shp de la capa de "
                        msg += "reclosers debe ser igual al nombre de la capa"
                        title = "Error al encontrar capa"
                        QMessageBox.information(None, title, msg)
                        return None
                    except KeyError:
                        recloser_layer = pd.DataFrame(np.nan, columns=cols_rec,
                                                  index=[])
                
                # DERs pequeña escala
                
                if layer_der_ss == [] or layer_der_ss == 0:
                    der_ss = pd.DataFrame()
                else:
                    try:
                        der_ss, layer_ders_ss = self.AttributeTable_ToDataframe(layer_der_ss[0])

                    except DriverError:
                        der_ss = pd.DataFrame(np.nan, columns=["KVA", "LV_GROUP"])
                        msg = "El nombre del archivo shp de la capa de "
                        msg += "DERs de pequeña escala debe ser igual al nombre de la capa"
                        title = "Error al encontrar capa"
                        QMessageBox.information(None, title, msg)
                        return None
               
                # DER gran escala
                
                if layer_der_ls == [] or layer_der_ls == 0:
                    der_ls = pd.DataFrame()
                else:
                    try:
                        der_ls, layer_ders_ls = self.AttributeTable_ToDataframe(layer_der_ls[0])

                    except DriverError:
                        der_ls = pd.DataFrame()
                        msg = "El nombre del archivo shp de la capa de "
                        msg += "DERs de gran escala debe ser igual al nombre de la capa"
                        title = "Error al encontrar capa"
                        QMessageBox.information(None, title, msg)
                        return None

                end_lectura_capas = time.time()
                
                print("Tiempo de lectura de capas: "+str(np.round(end_lectura_capas - start_lectura_capas,3))+" s")
                
                start = time.time()
                firstLine = self.firstLine(dir_network)  # first line name
                if firstLine == 0:
                    return
                Circuit = self.dlg.lineEdit_circuit_name.text()
                
                # Name of the load curve of the circuit
                load_curve_circuit = self.dlg.lineEdit_load_curve.text()
                if load_curve_circuit:
                    circuit_demand = loadFeederLoadCurve(load_curve_circuit)
                    if circuit_demand is None:
                        return None # Si la curva no es válida, sale del código     
                else:
                    msg = "Debe indicar la curva del alimentador. \n"
                    msg += "Recuerde que la extensión requerida es de tipo .csv"
                    QMessageBox.critical(None, "Error", msg)
                    return None

                snapshotdate = self.dlg.lineEdit_snapshot_date.text().upper()
                if not snapshotdate:
                    snapshotdate = auxfcns.selection_representative_day(load_curve_circuit, 'weekday')
                snapshottime = self.dlg.lineEdit_snapshot_time.text()
                
                if snapshotdate not in circuit_demand[0]:
                    msg = "La fecha no está incluida en el archivo de curva del alimentador del circuito \n"
                    msg += "Favor corregir. Verificar también que el formato de la fecha especificada coincida con el de la curva"
                    QMessageBox.critical(None, "Error", msg)
                    return None

                # Se selecciona si es large scale (ls) o small scale (ss) o estudio base (bs)
                current_index = self.dlg.tabWidget.currentIndex()
                bs = False
                ls = False
                ss = False

                if current_index == 0:
                    bs = True
                elif current_index == 1:
                    ls = True
                elif current_index == 2:
                    ss = True
                
                Overvoltage_analysis = False
                VoltageDeviation_analysis = False
                VoltageRegulation_analysis = False
                VoltageUnbalance = False
                Thermal_analysis = False

                RoR_analysis = False
                SympatheticTripping_analysis = False
                FF_analysis = False
                BFC_analysis = False

                tmp = setUpCOMInterface()
                DSSobj, DSSstart, DSStext, DSScircuit, DSSprogress = tmp
                Grafo = circuit_graph_mv(nodes_mv, lines_mv)  # Grafo

                # ? Leer como en el rojo
                tx_modelling = True
                line_tx_definition = ''
                substation_type = ''
                
                # Creacion de master
                firstLine = self.create_master(dir_network, name_file_created,
                                       tx_modelling, volt_nom)
                print("firstLine = ", firstLine)
                
                # #####################################################
                # #####################################################
                # ############## ESTUDIOS BASE ########################
                # #####################################################
                # #####################################################
                if bs is True:
                
                    if self.dlg.checkBox_estudiobase1.isChecked():
                        Estudio1 = True
                    else:
                        Estudio1 = False
                    
                    if self.dlg.checkBox_estudiobase3.isChecked():
                        Estudio2 = True
                    else:
                        Estudio2 = False
                
                    # Estudio 1: Verificación de los niveles de tensión
                    
                    if Estudio1 is True:
                        base_study_1(DSStext, DSScircuit, dir_network, firstLine)
                    
                    # Estudio 3: Snapshot de la red con DER existentes.
                    if Estudio2 is True:
                        base_study_2(DSSprogress, DSStext, DSScircuit, DSSobj, snapshotdate, snapshottime, dir_network, tx_modelling, firstLine, substation_type, 
                        line_tx_definition, der_ss, der_ls, circuit_demand)

                
                # #####################################################
                # #####################################################
                # ############## GRAN ESCALA ##########################
                # #####################################################
                # #####################################################
                
                elif ls is True:
                    report_txt = []
                    report_txt.append("************************* \n") 
                    report_txt.append("ESTUDIO DE GRAN ESCALA \n") 
                    report_txt.append("************************* \n") 
                    """
                    Criterios de tensión:
                    Son simulaciones de flujo de potencia en estado estable (snapshot)
                    """
                    # Sobretensión
                    if self.dlg.overvoltage_ls.isChecked():
                        Overvoltage_analysis = True
                    # Regulación de tensión
                    if self.dlg.checkBox_regulation_ls.isChecked():
                        VoltageRegulation_analysis = True
                    # Desbalance de tensión
                    if self.dlg.unbalance_ls.isChecked():
                        VoltageUnbalance = True
                    # Desviación de tensión
                    if self.dlg.voltage_deviation_ls.isChecked():
                        VoltageDeviation_analysis = True
                    """
                    Criterios de protecciones:
                    Son simulaciones con fallas, cortos circuitos
                    """
                    
                    # Aumento de corriente de falla
                    if self.dlg.cf_ls.isChecked():
                        FF_analysis = True
                    # Disparo simpático
                    if self.dlg.st_ls.isChecked():
                        SympatheticTripping_analysis = True
                    # Coordinación recloser-fusible
                    if self.dlg.coord_rf_ls.isChecked():
                        BFC_analysis = True
                    # Reducción de alcance (RoR)
                    if self.dlg.rr_ls.isChecked():
                        RoR_analysis = True
                    
                    # Para saber si al menos hay un criterio de protección a evaluar 
                    protec_analysis = ((FF_analysis) or (SympatheticTripping_analysis) or (BFC_analysis) or (RoR_analysis))

                    # Criterios termicos
                    if self.dlg.checkBox_thermal_ls.isChecked():
                        Thermal_analysis = True

                    # Fallas seleccionadas
                    faulttypes = []
                    if self.dlg.Box_faults_ls.isEnabled():
                        if self.dlg.abcg_ls.isChecked():
                            faulttypes.append('ABCG')
                        if self.dlg.abg_ls.isChecked():
                            faulttypes.append('ABG')
                        if self.dlg.bcg_ls.isChecked():
                            faulttypes.append('BCG')
                        if self.dlg.acg_ls.isChecked():
                            faulttypes.append('ACG')
                        if self.dlg.ab_ls.isChecked():
                            faulttypes.append('AB')
                        if self.dlg.bc_ls.isChecked():
                            faulttypes.append('BC')
                        if self.dlg.ac_ls.isChecked():
                            faulttypes.append('AC')
                        if self.dlg.ag_ls.isChecked():
                            faulttypes.append('AG')
                        if self.dlg.bg_ls.isChecked():
                            faulttypes.append('BG')
                        if self.dlg.cg_ls.isChecked():
                            faulttypes.append('CG')
                    
                    # Parámetros estudios
                    max_increase_bfc = self.dlg.inc_max_rf_ls.value()
                    max_reduction = self.dlg.red_max_ls.value()
                    max_reduction = 1 - max_reduction/100
                    I_trip_51p = self.dlg.I_trip_51p_ls.value()
                    I_trip_51g = self.dlg.I_trip_51g_ls.value()
                    max_increase_ff = self.dlg.max_perc_cf_ls.value()
                    max_increase_ff = 1 + max_increase_ff/100
                    max_lv_dev = self.dlg.unbalance_bt_ls.value()/100
                    max_mv_dev = self.dlg.unbalance_mt_ls.value()/100
                    max_v_unb = self.dlg.unb_max_ls.value()
                    max_v_unb = max_v_unb/100
                    max_v = self.dlg.overvolt_ls.value()
                    # Otros parámetros
                    TotalCapacityMax = self.dlg.maximum_capacity_ls.value()
                    der_step = self.dlg.steps_ls.value()
                    
                    # Aporte de cortocircuito RD
                    
                    self.select_type_DER()
                    
                    if self.dlg.DER_PV.isChecked():
                        der_type = "INV"
                        der_type_val = self.dlg.ap_cc_ls.value()/100
                    elif self.dlg.DER_MS.isChecked():
                        der_type = "MS"
                        der_type_val = self.dlg.ap_ms.value()

                    # Caso en que no seleccione ningún análisis
                    if (Overvoltage_analysis is False and VoltageDeviation_analysis is False and
                            VoltageRegulation_analysis is False and VoltageUnbalance is False and
                            Thermal_analysis is False and RoR_analysis is False and
                            SympatheticTripping_analysis is False and FF_analysis is False
                            and BFC_analysis is False):
                        msg  = "No seleccionó ningún análisis"
                        title = "Final"
                        QMessageBox.information(None, title, msg)
                        return None
                    
                    # Caso en el que se seleccione un estudio con protecciones, pero no hay capa de fusibles ni reclosers:
                    if ((protec_analysis is True) and (fuse_layer.empty is True and recloser_layer.empty is True)):
                        msg  = "Se seleccionó un estudio de protecciones, pero las capas de fusibles y reclosers no están dentro del modelo"
                        title = "Final"
                        QMessageBox.information(None, title, msg)
                        return None
                        
                    # Caso en el que se seleccione un estudio con protecciones, pero no hay tipo de fallas seleccionadas:
                    if (protec_analysis is True) and (len(faulttypes) == 0):
                        msg  = "Se seleccionó un estudio de protecciones, pero no se seleccionó ningún tipo de falla"
                        title = "Final"
                        QMessageBox.information(None, title, msg)
                        return None
                    
                    # Reporte de criterios utilizados para el reporte de texto
                    report_txt.append("CRITERIOS SELECCIONADOS: \n ")
                    # Sobretensión
                    if Overvoltage_analysis is True:
                        report_txt.append("V: Sobretensión - Valor máximo: "+str(max_v)+" pu \n")
                    # Desviación de tensión: 
                    if VoltageDeviation_analysis is True:
                        report_txt.append("V: Desviación de tensión - Porcentajes máximos: MT: "+str(np.round(100*max_mv_dev,2))+ " % - BT: "+str(np.round(100*max_lv_dev,2)) + " % \n")
                    # Desbalance de tensión
                    if VoltageUnbalance is True:
                        report_txt.append("V: Desbalance de tensión - Porcentaje máximo: "+str(np.round(100*max_v_unb,2))+ " % \n")
                    # Regulación de tensión 
                    if VoltageRegulation_analysis is True:
                        report_txt.append("V: Regulación de tensión \n")
                    # Térmicos
                    if Thermal_analysis is True:
                        report_txt.append("T: Térmicos")
                    # Aumento de corriente de falla:
                    if FF_analysis is True:
                        report_txt.append("P: Aumento de corriente de falla - Porcentaje máximo: "+str(np.round((max_increase_ff-1)*100,2))+" % \n")
                    # Reducción de alcance
                    if RoR_analysis is True:
                        report_txt.append("P: Reducción de alcance - Porcentaje mínimo: "+str(np.round((max_reduction+1)*100,2))+" % \n")
                    # Coordinación recloser-fusible
                    if BFC_analysis is True:
                        report_txt.append("P: Coordinación recloser-fusible - Corriente máxima de incremento: "+str(np.round(max_increase_bfc,2))+" A \n") 
                    # Disparo indebido:
                    if SympatheticTripping_analysis is True:
                        report_txt.append("P: Disparo indebido \n") 
                    # Tipo de fallas estudiadas
                    if ((FF_analysis) or (RoR_analysis) or (BFC_analysis) or (SympatheticTripping_analysis)) is True:
                        report_txt.append("Las fallas seleccionadas son las siguientes: "+str(faulttypes)+" \n") 
                    # Otras propiedades seleccionadas:
                    report_txt.append("************************* \n") 
                    report_txt.append("Otras propiedades seleccionadas \n") 
                    report_txt.append("************************* \n") 
                    # Límite de instalación:
                    report_txt.append("El límite de DERs seleccionados en la simulación es de: "+str(TotalCapacityMax)+" kW \n")
                    # Steps:
                    report_txt.append("El paso o cantidad máxima asignada por iteración es de: "+str(der_step)+" kW \n")
                    # Tipo de generador
                    
                    if der_type == "INV":
                        report_txt.append("Los generadores a simular son basados en inversores \n")
                        report_txt.append("El aporte de cortocircuito de los generadores es de " +str(der_type_val*100)+" % de su respectiva corriente nominal \n")
                    else:
                        report_txt.append("Los generadores a simular son basados en máquina sincrónica + \n")
                        report_txt.append("La reactancia transitoria de los generadores es de" +str(der_type_val)+" pu \n")
                    
                    report_txt.append("************************* \n") 
                    report_txt.append("Análisis inicial del circuito \n") 
                    report_txt.append("************************* \n") 

                    # Cálculos
                    vect = distance_nodes_MV(Grafo, nodes_mv, lines_mv, tx_layer, fixed_distance)
                    print("vect = ", vect)
                    chosen_buses_dict, chosen_buses_list, chosen_buses_df = vect
                    print("chosen_buses_df = ", chosen_buses_df)

                    # % SALIDAS DE FUNCIONES QUE CREAN DATAFRAMES DE PROTECCIONES
                    if protec_analysis is True:
                        CircuitBreakDvRoR, CircuitBreakDvFF_BFC = pDevices(Grafo, firstLine, fuse_layer, recloser_layer, FF_analysis, BFC_analysis)
                    else:
                        CircuitBreakDvRoR = pd.DataFrame()
                        CircuitBreakDvFF_BFC = pd.DataFrame()

                    # CIRCUIT BASE POWER FLOW
                    VBuses_b, Base_V = getbases(DSStext, DSScircuit, dir_network,
                                                firstLine, lv_groups, tx_groups)
                    loadslv_buses, loadsmv_buses = getloadbuses(circname_azul + '_LoadsLV',
                                                                circname_azul + '_LoadsMV',
                                                                dir_network)
                    # Gets all the loads buses # Gets all the loads buses
                    x = base_Case_Run(DSStext, DSScircuit,
                                      DSSobj, DSSprogress,
                                      snapshotdate, snapshottime,
                                      firstLine, tx_modelling, substation_type,
                                      line_tx_definition, circuit_demand, Base_V,
                                      CircuitBreakDvFF_BFC, CircuitBreakDvRoR,
                                      faulttypes, dir_network, lv_loads_layer,
                                      mv_loads_layer, tx_layer,
                                      FF_analysis, BFC_analysis,
                                      RoR_analysis)
                    NoDERsPF_Vbuses = x[0]
                    No_DER_FFCurrents = x[1]
                    No_DER_RoRCurrents = x[2]
                    No_DER_BFCCurrents = x[3]
                    kW_sim = x[4]
                    kVAr_sim = x[5]
                    reg_taps = x[6]
                    cap_steps = x[7]
                    lv_loads_layer = x[8]
                    
                    report_txt.append("Estudio base: Listo! \n") 
                    
                    # Función para determinar el nivel inicial de DER en el sistema:
                    DERinstalled_buses_ini, DERinstalled_ini = getGDinstalled(der_ss)
                    
                    report_txt.append("El circuito posee "+str(DERinstalled_ini)+" kW de DER instalados desde el inicio \n") 

                    # Verificar (si puede ser vacío sin errores)
                    if NoDERsPF_Vbuses.empty is True:
                        return None

                    normalAmpsDic = normalAmps(DSScircuit)  # Gets normal capacity for lines

                    MCSim = 1  # Total Monte Carlo Simulations
                   
                    # begins the HC study
                    # While loop. It'll stop when all the MV_Groups are flagged
                    # begin with the loop whose variable is distance
                    
                    report_txt.append("************************* \n") 
                    report_txt.append("Estudio de Capacidad de Alojamiento \n") 
                    report_txt.append("************************* \n")
                    
                    redo_sim = False
                    last_blacklisted_ov = []
                    last_blacklisted_vd = []
                    time_data = {}
                    voltage_vals = {}
                    overvoltage_vals = {}
                    
                    report_dict = {}  # dict with all the info.
                    

                    for bus in chosen_buses_df.index.values:  # goes over the node step
                        start_t_bus = time.time()
                        report_dict[bus] = {}
                        report_dict[bus]['distance'] = chosen_buses_df.loc[bus, 'distance']
                        report_dict[bus]['max_kVA'] = 0
                        report_dict[bus]['vtp_criteria'] = {}

                        blacklist = []
                        blacklist_dict = {}

                        node_tuple = (bus, chosen_buses_df.loc[bus, 'nomvolt'])

                        Overvoltage_loads_df = pd.DataFrame()
                        Voltagedeviation_loads_df = pd.DataFrame()
                        Overvoltage_rest_df = pd.DataFrame()
                        Voltagedeviation_rest_df = pd.DataFrame()
                        Voltagedeviation_reg_df = pd.DataFrame()
                        Voltageunbalance_df = pd.DataFrame()
                        Thermal_loading_lines_df = pd.DataFrame()
                        Thermal_loading_tx_df = pd.DataFrame()
                        FFCurrents = pd.DataFrame()
                        RoRCurrents = pd.DataFrame()
                        BFCCurrents = pd.DataFrame()
                        SympatheticTripping_df = pd.DataFrame()
                        linelvgroups = []

                        # Now a node is selected, so we need to iterate over the
                        # installed capacity on that node
                        # to analyze the hosting capacity

                        flag = False
                        n_loop = 1
                        capacity_i = 0

                        while flag is False and n_loop*der_step <= TotalCapacityMax:
                            capacity_i = n_loop*der_step
                            blacklist = []
                            msg = "\n Simulación - Capacidad instalada: "
                            msg += str(capacity_i) + ' kW en la barra:'
                            msg += str(node_tuple[0]) + ' a una distancia desde la cabecera del circuito: '
                            msg += str(np.round(chosen_buses_df.loc[bus, 'distance']/1000,2)) + " km"
                            print(msg)
                            
                            report_txt.append(msg)

                            # initialize the variables
                            Trafos = []
                            Trafos_Monitor = []
                            DERs = []

                            Trafos, Trafos_Monitor, DERs = trafos_and_DERs_text_command([node_tuple],
                                                                                        capacity_i, der_type, der_type_val)

                            # Compile model for simulation - run simulation taking into
                            # consideration the new GD installed
                            DERs_Run(DSStext, DSScircuit, snapshotdate,
                                     snapshottime, firstLine,
                                     tx_modelling, substation_type,
                                     line_tx_definition, circuit_demand,
                                     Base_V, kW_sim, kVAr_sim,
                                     DERs, Trafos, dir_network, reg_taps, cap_steps)

                            # Check HC criteria - Here, the results
                            # dataframes are updated, with all limiting
                            # criteria characteristics being monitored
                            DSScircuit.setActiveElement('line.' + firstLine)
                            temp_powers = DSScircuit.ActiveElement.Powers
                            numb = temp_powers[0] + temp_powers[2] + temp_powers[4]
                            msg = 'P_w_Sub: ' + str(numb)
                            print(msg)

                            # Check HC criteria - Here, the results dataframes are
                            # updated, with all limiting criteria
                            # characteristics being monitored
                            x = pq_voltage(DSScircuit, DSStext, dir_network, Base_V, loadslv_buses, loadsmv_buses,
                                            regs, caps, capacity_i, lv_groups, tx_groups, NoDERsPF_Vbuses,
                                            Overvoltage_loads_df, Overvoltage_rest_df,
                                            Voltagedeviation_loads_df, Voltagedeviation_rest_df,
                                            Voltagedeviation_reg_df, Voltageunbalance_df,
                                            Overvoltage_analysis, VoltageDeviation_analysis,
                                            VoltageRegulation_analysis, VoltageUnbalance,
                                            max_v, max_lv_dev, max_mv_dev, max_v_unb, 
                                            redo_sim, last_blacklisted_ov, last_blacklisted_vd, voltage_vals, overvoltage_vals, 
                                            report_txt)
                                                
                            VBuses = x[0]
                            Overvoltage_loads_df = x[1]
                            Voltagedeviation_loads_df = x[2]
                            Overvoltage_rest_df = x[3]
                            Voltagedeviation_rest_df = x[4]
                            Voltagedeviation_reg_df = x[5]
                            Voltageunbalance_df = x[6]
                            last_blacklisted_vd = x[7]
                            temp_VDlr_list = x[8]
                            voltage_vals = x[9]
                            overvoltage_vals = x[10]
                            report_txt = x[11]

                            x = thermal_Lines_Tx(DSScircuit, DSStext, normalAmpsDic,
                                                 capacity_i, line_lv_groups, tx_groups,
                                                 Thermal_loading_lines_df, Thermal_loading_tx_df,
                                                 name_file_created, linelvgroups, Thermal_analysis, report_txt)
                            Thermal_loading_lines_df, Thermal_loading_tx_df, CurrentDF, report_txt = x

                            FFCurrents, BFCCurrents, report_txt = FF_BFC_Current(DSScircuit, DSStext,
                                                                     dir_network, firstLine,
                                                                     snapshottime, snapshotdate, circuit_demand,
                                                                     kW_sim, kVAr_sim,  capacity_i,
                                                                     Trafos, DERs, No_DER_FFCurrents,
                                                                     FFCurrents, No_DER_BFCCurrents,
                                                                     BFCCurrents, faulttypes,
                                                                     FF_analysis, BFC_analysis,
                                                                     max_increase_ff, max_increase_bfc, report_txt)

                            RoRCurrents, report_txt = ReductionReach(DSScircuit, DSStext,
                                                         dir_network, firstLine,
                                                         snapshottime, snapshotdate,
                                                         kW_sim, kVAr_sim, circuit_demand, capacity_i,
                                                         Trafos, DERs, No_DER_RoRCurrents,
                                                         RoRCurrents, faulttypes, RoR_analysis,
                                                         max_reduction, report_txt)

                            SympatheticTripping_df, report_txt = SympatheticTripping(DSStext, DSScircuit,
                                                                         dir_network, firstLine,
                                                                         snapshotdate, snapshottime,
                                                                         kW_sim, kVAr_sim, circuit_demand, 
                                                                         capacity_i, Trafos, DERs,
                                                                         SympatheticTripping_analysis,
                                                                         faulttypes, I_trip_51p, I_trip_51g,
                                                                         SympatheticTripping_df, report_txt)

                            msg = 'Checkpoint - distancia = '
                            msg += str(np.round(chosen_buses_df.loc[bus, 'distance']/1000,2)) + " km"
                            msg += ' barra= ' + str(node_tuple[0])
                            msg += ' Capacidad instalada: ' + str(capacity_i) +" kW"
                            print(msg)
                            report_txt.append(msg)

                            # at the end:
                            x = flag_and_blacklist_calc(Overvoltage_loads_df, Voltagedeviation_loads_df,
                                                        Overvoltage_rest_df, Voltagedeviation_rest_df,
                                                        Voltagedeviation_reg_df, Voltageunbalance_df,
                                                        Thermal_loading_lines_df, Thermal_loading_tx_df,
                                                        FFCurrents, BFCCurrents, RoRCurrents,
                                                        SympatheticTripping_df, Overvoltage_analysis,
                                                        VoltageDeviation_analysis, VoltageRegulation_analysis,
                                                        VoltageUnbalance, Thermal_analysis,
                                                        FF_analysis, BFC_analysis, RoR_analysis,
                                                        SympatheticTripping_analysis, tx_groups,
                                                        capacity_i, flag, blacklist, blacklist_dict)
                            flag, flag_list, blacklist, blacklist_dict, redo_sim = x

                            if flag is False:
                                if redo_sim is False:
                                    if capacity_i < TotalCapacityMax:
                                        print('Checkpoint - Capacidad instalada: '+str(capacity_i))
                                        #at the end:
                                        n_loop += 1
                                    else:
                                        msg = 'Checkpoint Final - Máxima capacidad alcanzada: '
                                        msg +=  str(capacity_i)
                                        print(msg)
                                        # report_txt.append(msg)
                                        final_der = capacity_i
                                        chosen_buses_df.loc[bus, 'max_kVA'] = final_der
                                        chosen_buses_df.loc[bus, 'flag'] = 'None'
                                        
                                        
                                        report_dict[bus]['max_kVA'] = final_der
                                        tmp = save_criteria_data_iterative(report_dict[bus]['vtp_criteria'],
                                                                           Overvoltage_loads_df,
                                                                           Voltagedeviation_loads_df, 
                                                                           Overvoltage_rest_df, Voltagedeviation_rest_df,
                                                                           Voltagedeviation_reg_df,
                                                                           Voltageunbalance_df,
                                                                           Thermal_loading_lines_df,
                                                                           Thermal_loading_tx_df,
                                                                           FFCurrents, BFCCurrents,
                                                                           RoRCurrents, SympatheticTripping_df)
                                        
                                        report_dict[bus]['vtp_criteria'] = tmp
                                        end_t_bus = time.time()
                                        sim_time_t_bus = end_t_bus - start_t_bus
                                        msg = 'Tiempo de simulación: '
                                        msg += str(round(sim_time_t_bus,2)) + ' s.'
                                        print(msg)
                                        #at the end:
                                        n_loop += 1
                                else:
                                    final_der = capacity_i
                                    chosen_buses_df.loc[bus, 'max_kVA'] = final_der
                                    chosen_buses_df.loc[bus, 'flag'] = 'tensión/térmicos'
                                    msg = 'Checkpoint - Capacidad: ' + str(capacity_i)
                                    msg += ' kW - existen problemas de tensión o térmicos '
                                    print(msg)
                                    report_txt.append(msg)
                                    
                                    report_dict[bus]['max_kVA'] = final_der
                                    report_dict[bus]['vtp_criteria'] = save_criteria_data_iterative(report_dict[bus]['vtp_criteria'],
                                                                                                    Overvoltage_loads_df, Voltagedeviation_loads_df, 
                                                                                                    Overvoltage_rest_df, Voltagedeviation_rest_df,
                                                                                                    Voltagedeviation_reg_df, 
                                                                                                    Voltageunbalance_df, Thermal_loading_lines_df,
                                                                                                    Thermal_loading_tx_df, 
                                                                                                    FFCurrents, BFCCurrents,
                                                                                                    RoRCurrents, SympatheticTripping_df)
                                    flag = True
                                    end_t_bus = time.time()
                                    sim_time_t_bus = end_t_bus - start_t_bus
                                    msg = 'Tiempo de simulación: ' + str(round(sim_time_t_bus,2)) + ' s.'
                                    print(msg)
                                    report_txt.append(msg)

                            else:
                                msg = 'Checkpoint Final - La máxima capacidad instalada fue de: '
                                msg += str(capacity_i - der_step)
                                report_txt.append(msg)
                                print(msg)
                                
                                flag_list_str = ''
                                for crit in range(len(flag_list)):
                                    if len(flag_list) == 1:
                                        flag_list_str += flag_list[crit]
                                    else:
                                        if crit < (len(flag_list)-2):
                                            flag_list_str += flag_list[crit] + ', '
                                        elif crit == (len(flag_list)-2):
                                            flag_list_str += flag_list[crit] + ' and '
                                        else:
                                            flag_list_str += flag_list[crit]

                                msg = 'El/los criterios ' + flag_list_str
                                msg += ' pararon la simulación' 
                                print(msg)
                                report_txt.append(msg)
                                
                                final_der = capacity_i - der_step
                                chosen_buses_df.loc[bus, 'max_kVA'] = final_der
                                chosen_buses_df.loc[bus, 'flag'] = flag_list_str
                                
                                report_dict[bus]['max_kVA'] = final_der
                                tmp = save_criteria_data_iterative(report_dict[bus]['vtp_criteria'],
                                                                   Overvoltage_loads_df,
                                                                   Voltagedeviation_loads_df,
                                                                   Overvoltage_rest_df,
                                                                   Voltagedeviation_rest_df,
                                                                   Voltagedeviation_reg_df,
                                                                   Voltageunbalance_df,
                                                                   Thermal_loading_lines_df,
                                                                   Thermal_loading_tx_df,
                                                                   FFCurrents, BFCCurrents,
                                                                   RoRCurrents, SympatheticTripping_df)
                                report_dict[bus]['vtp_criteria'] = tmp
                                end_t_bus = time.time()
                                sim_time_t_bus = end_t_bus - start_t_bus
                                msg = 'Tiempo de simulación: '
                                msg += str(round(sim_time_t_bus,2)) + ' s.'
                                print(msg)
                                # report_txt.append(msg)

                            if n_loop*der_step > TotalCapacityMax:
                                final_der = capacity_i
                                chosen_buses_df.loc[bus, 'max_kVA'] = final_der
                                chosen_buses_df.loc[bus, 'flag'] = 'Max_cap'

                                report_dict[bus]['max_kVA'] = final_der
                                tmp = save_criteria_data_iterative(report_dict[bus]['vtp_criteria'],
                                                                   Overvoltage_loads_df,
                                                                   Voltagedeviation_loads_df,
                                                                   Overvoltage_rest_df,
                                                                   Voltagedeviation_rest_df,
                                                                   Voltagedeviation_reg_df,
                                                                   Voltageunbalance_df,
                                                                   Thermal_loading_lines_df,
                                                                   Thermal_loading_tx_df,
                                                                   FFCurrents, BFCCurrents,
                                                                   RoRCurrents, SympatheticTripping_df)

                                report_dict[bus]['vtp_criteria'] = tmp
                                end_t_bus = time.time()
                                sim_time_t_bus = end_t_bus - start_t_bus
                                msg = 'Tiempo de simulación: ' + str(round(sim_time_t_bus,2)) +" s \n"
                                msg += 'Checkpoint Final  - La máxima capacidad definida fue alcanzada '
                                msg += str(capacity_i) + " kW"
                                print(msg)
                                report_txt.append(msg)
                    
                    # Inicio
                    Voltage_comp  = Overvoltage_analysis and VoltageDeviation_analysis and VoltageRegulation_analysis and VoltageUnbalance
                    Prot_comp = FF_analysis and BFC_analysis and RoR_analysis

                    tmp = data_grouping_iterative(Grafo, chosen_buses_df, fixed_distance,
                                                  lines_mv, lines_mv_oh_layer_original,
                                                  lines_mv_ug_layer_original)
                                                  
                    lines_mv_oh_layer_original = tmp[0]
                    lines_mv_ug_layer_original = tmp[1]
                    name_col = "HC_RES_LS"

                    # Guardan resultados
                    self.msg_final += "\nResultados gran escala:\n"
                    
                    col_sel = ['distance', 'max_kVA', 'flag']
                    # try:
                        # out_chosen_buses = chosen_buses_df[col_sel]
                        # out_chosen_buses.to_csv(self.output + "/chosen_buses.csv")
                        # self.msg_final += str(out_chosen_buses)
                    # except Exception:
                        # chosen_buses_df.to_csv(self.output + "/chosen_buses.csv")
                        # self.msg_final += str(chosen_buses_df)
                    
                    # Se guardan los resultados en un txt
                    output_ = self.output + '/Resultados_ls.txt'
                    with open(output_, 'w') as file_:
                        file_.write(self.msg_final)
                        
                    n_ranges = []  # Declare the ranges variable outside the if statements
                    
                    if layer_mt_aer != [] and layer_mt_aer != 0:
                        self.save_dataframe(lines_mv_oh_layer_original,
                                            layer_mv_oh, name_col)
                        n_ranges = self.categ_layer(lines_mv_oh_layer_original,
                                         layer_mv_oh, name_col)
                    if layer_mt_sub != [] and layer_mt_sub != 0:
                        self.save_dataframe(lines_mv_ug_layer_original,
                                            layer_mv_ug, name_col)
                        n_ranges2 = self.categ_layer(lines_mv_ug_layer_original,
                                            layer_mv_ug, name_col, n_ranges)
                    
                    # Crea carpeta para resultados en caso de que no exista
                    res_ls_dir = dir_general+"\\HC_RES_LS"
                    res_ls_crit_dir = res_ls_dir+"\\Resultados_Criterios"
                    
                    if not os.path.exists(res_ls_dir):
                        os.makedirs(res_ls_dir)
                    
                    # Guarda el reporte de resultados
                    with open(res_ls_dir+'\\seguimiento_resultados.txt', 'w') as f:
                        f.writelines("%s\n" % line for line in report_txt)


                    end = time.time()
                    sim_time = end - start
                    msg = 'Tiempo de simulación: ' + str(round(sim_time/60, 2)) + ' min.'
                    print(msg)
                    
                    msg  = "Simulación finalizada exitosamente \n"
                    msg += 'Tiempo de simulación: '
                    msg += str(round(sim_time/60, 2)) + ' min.'
                    msg += "\n Los resultados se guardaron en el siguiente "
                    msg += "directorio: " + res_ls_dir
                    title = "Final"
                    QMessageBox.information(None, title, msg)

                # #####################################################
                # #####################################################
                # ################ PEQUEÑA ESCALA #####################
                # #####################################################
                # #####################################################
                elif ss is True:
                    report_txt = []
                    report_txt.append("************************* \n") 
                    report_txt.append("ESTUDIO DE PEQUEÑA ESCALA \n") 
                    report_txt.append("************************* \n") 
                    """
                    Criterios de tensión:
                    Son simulaciones de flujo de potencia en estado estable (snapshot)
                    """
                    # Sobretensión
                    if self.dlg.overvoltage_ss.isChecked():
                        Overvoltage_analysis = True
                    # Regulación de tensión
                    if self.dlg.checkBox_regulation_ss.isChecked():
                        VoltageRegulation_analysis = True
                    # Desbalance de tensión
                    if self.dlg.unbalance_ss.isChecked():
                        VoltageUnbalance = True
                    # Desviación de tensión
                    if self.dlg.voltage_deviation_ss.isChecked():
                        VoltageDeviation_analysis = True

                    """
                    Criterios de protecciones:
                    Son simulaciones con fallas, cortos circuitos
                    """
                    # Aumento de corriente de falla
                    if self.dlg.cf_ss.isChecked():
                        FF_analysis = True
                        
                    # Disparo simpático
                    if self.dlg.st_ss.isChecked():
                        SympatheticTripping_analysis = True
                        
                    # Coordinación recloser-fusible
                    if self.dlg.coord_rf_ss.isChecked():
                        BFC_analysis = True
                        
                    # Reducción de alcance (RoR)
                    if self.dlg.rr_ss.isChecked():
                        RoR_analysis = True
                        
                    # Para saber si al menos hay un criterio de protección a evaluar 
                    protec_analysis = ((FF_analysis) or (SympatheticTripping_analysis) or (BFC_analysis) or (RoR_analysis))
                    
                    """
                    Criterios térmicos:
                    """
                    # Criterios termicos
                    if self.dlg.checkBox_thermal_ss.isChecked():
                        Thermal_analysis = True
                    
                    # Limitar instalación máxima del trafo
                    if self.dlg.checkBox_lim_cap_traf.isChecked():
                        lim_kVA = True
                    else:
                        lim_kVA = False
                        
                    # Fallas seleccionadas
                    faulttypes = []
                    if self.dlg.Box_faults_ss.isEnabled():
                        if self.dlg.abcg_ss.isChecked():
                            faulttypes.append('ABCG')
                        if self.dlg.abg_ss.isChecked():
                            faulttypes.append('ABG')
                        if self.dlg.bcg_ss.isChecked():
                            faulttypes.append('BCG')
                        if self.dlg.acg_ss.isChecked():
                            faulttypes.append('ACG')
                        if self.dlg.ab_ss.isChecked():
                            faulttypes.append('AB')
                        if self.dlg.bc_ss.isChecked():
                            faulttypes.append('BC')
                        if self.dlg.ac_ss.isChecked():
                            faulttypes.append('AC')
                        if self.dlg.ag_ss.isChecked():
                            faulttypes.append('AG')
                        if self.dlg.bg_ss.isChecked():
                            faulttypes.append('BG')
                        if self.dlg.cg_ss.isChecked():
                            faulttypes.append('CG')
                    
                    # Parametros de estudios
                    max_reduction = self.dlg.red_max_ss.value()
                    max_reduction = 1 - max_reduction/100
                    max_increase_bfc = self.dlg.inc_max_rf_ss.value()
                    I_trip_51p = self.dlg.I_trip_51p_ss.value()
                    I_trip_51g = self.dlg.I_trip_51g_ss.value()
                    max_increase_ff = self.dlg.max_perc_cf_ss.value()
                    max_increase_ff = 1 + max_increase_ff/100
                    max_v = self.dlg.overvolt_ss.value()
                    max_v_unb = self.dlg.unb_max_ss.value()
                    max_v_unb = max_v_unb/100
                    max_lv_dev = self.dlg.unbalance_bt_ss.value()/100
                    max_mv_dev = self.dlg.unbalance_mt_ss.value()/100
                    # Otros parámetros
                    TotalCapacityMax = self.dlg.maximum_capacity_ss.value()
                    max_kVA_step = self.dlg.steps_lv_ss.value()
                    max_kVA_mvloads = self.dlg.steps_mv_ss.value()
                    # Aporte de cortocircuito RD
                    icc_ss = self.dlg.ap_cc_ss.value()/100

                    # Caso en que no seleccione ningún análisis
                    if (Overvoltage_analysis is False and VoltageDeviation_analysis is False and
                            VoltageRegulation_analysis is False and VoltageUnbalance is False and
                            Thermal_analysis is False and RoR_analysis is False and
                            SympatheticTripping_analysis is False and FF_analysis is False
                            and BFC_analysis is False):
                        msg  = "No seleccionó ningún análisis"
                        title = "Final"
                        QMessageBox.information(None, title, msg)
                        return None
                    
                    # Caso en el que se seleccione un estudio con protecciones, pero no hay capa de fusibles ni reclosers:
                    if ((protec_analysis is True) and (fuse_layer.empty is True and recloser_layer.empty is True)):
                        msg  = "Se seleccionó un estudio de protecciones, pero las capas de fusibles y reclosers no están dentro del modelo"
                        title = "Final"
                        QMessageBox.information(None, title, msg)
                        return None
                    
                    # Caso en el que se seleccione un estudio con protecciones, pero no hay tipo de fallas seleccionadas:
                    if (protec_analysis is True) and (len(faulttypes) == 0):
                        msg  = "Se seleccionó un estudio de protecciones, pero no se seleccionó ningún tipo de falla"
                        title = "Final"
                        QMessageBox.information(None, title, msg)
                        return None
                        
                    # Reporte de criterios utilizados para el reporte de texto
                    report_txt.append("CRITERIOS SELECCIONADOS: \n ")
                    # Sobretensión
                    if Overvoltage_analysis is True:
                        report_txt.append("V: Sobretensión - Valor máximo: "+str(max_v)+" pu \n")
                    # Desviación de tensión: 
                    if VoltageDeviation_analysis is True:
                        report_txt.append("V: Desviación de tensión - Porcentajes máximos: MT: "+str(np.round(100*max_mv_dev,2))+ " % - BT: "+str(np.round(100*max_lv_dev,2)) + " % \n")
                    # Desbalance de tensión
                    if VoltageUnbalance is True:
                        report_txt.append("V: Desbalance de tensión - Porcentaje máximo: "+str(np.round(100*max_v_unb,2))+ " % \n")
                    # Regulación de tensión 
                    if VoltageRegulation_analysis is True:
                        report_txt.append("V: Regulación de tensión \n")
                    # Térmicos
                    if Thermal_analysis is True:
                        report_txt.append("T: Térmicos")
                    # Aumento de corriente de falla:
                    if FF_analysis is True:
                        report_txt.append("P: Aumento de corriente de falla - Porcentaje máximo: "+str(np.round((max_increase_ff-1)*100,2))+" % \n")
                    # Reducción de alcance
                    if RoR_analysis is True:
                        report_txt.append("P: Reducción de alcance - Porcentaje mínimo: "+str(np.round((max_reduction+1)*100,2))+" % \n")
                    # Coordinación recloser-fusible
                    if BFC_analysis is True:
                        report_txt.append("P: Coordinación recloser-fusible - Corriente máxima de incremento: "+str(np.round(max_increase_bfc,2))+" A \n") 
                    # Disparo indebido:
                    if SympatheticTripping_analysis is True:
                        report_txt.append("P: Disparo indebido \n") 
                    # Tipo de fallas estudiadas
                    if ((FF_analysis) or (RoR_analysis) or (BFC_analysis) or (SympatheticTripping_analysis)) is True:
                        report_txt.append("Las fallas seleccionadas son las siguientes: "+str(faulttypes)+" \n") 
                    # Otras propiedades seleccionadas:
                    report_txt.append("************************* \n") 
                    report_txt.append("Otras propiedades seleccionadas \n") 
                    report_txt.append("************************* \n") 
                    # Topeo de transformadores
                    if lim_kVA is True:
                        report_txt.append("Se seleccionó la opción de limitar la instalación de DER en el secundario de acuerdo a la capacidad del transformador correspondiente \n")
                    else:
                        report_txt.append("NO se seleccionó la opción de limitar la instalación de DER en el secundario de acuerdo a la capacidad del transformador correspondiente \n")
                    # Límite de instalación:
                    report_txt.append("El límite de DERs seleccionados en la simulación es de: "+str(TotalCapacityMax)+" kW \n")
                    # Steps:
                    report_txt.append("El paso o cantidad máxima asignada al secundario con mayor demanda es de: "+str(max_kVA_step)+" kW \n")
                    report_txt.append("El paso o cantidad máxima asignada a la carga MT de mayor demanda es de: "+str(max_kVA_mvloads)+" kW \n")
                    # Aporte de corto
                    report_txt.append("El aporte de cortocircuito para cada DER instalado es de " +str(icc_ss)+" % de su respectiva corriente nominal \n")
                    
                    report_txt.append("************************* \n") 
                    report_txt.append("Análisis inicial del circuito \n") 
                    report_txt.append("************************* \n") 
                    
                    # % SALIDAS DE FUNCIONES QUE CREAN DATAFRAMES DE PROTECCIONES
                    if protec_analysis is True:
                        CircuitBreakDvRoR, CircuitBreakDvFF_BFC = pDevices(Grafo, firstLine, fuse_layer, recloser_layer, FF_analysis, BFC_analysis)
                        cols = ['BUSINST', 'VREG', 'BANDWIDTH']
                    else:
                        CircuitBreakDvRoR = pd.DataFrame()
                        CircuitBreakDvFF_BFC = pd.DataFrame()
                    

                    # %% CIRCUIT BASE POWER FLOW
                    VBuses_b, Base_V = getbases(DSStext, DSScircuit,
                                                dir_network, firstLine,
                                                lv_groups, tx_groups)
                    loadslv_buses, loadsmv_buses = getloadbuses(circname_azul + '_LoadsLV',
                                                                circname_azul + '_LoadsMV',
                                                                dir_network)
                    
                    # Gets all the loads buses # Gets all the loads buses
                    vect_ret = base_Case_Run(DSStext, DSScircuit, DSSobj, DSSprogress,
                                            snapshotdate, snapshottime, firstLine,
                                            tx_modelling, substation_type, line_tx_definition,
                                            circuit_demand, Base_V, CircuitBreakDvFF_BFC,
                                            CircuitBreakDvRoR, faulttypes, dir_network,
                                            lv_loads_layer, mv_loads_layer, tx_layer,
                                            FF_analysis, BFC_analysis, RoR_analysis)
                    NoDERsPF_Vbuses = vect_ret[0]
                    No_DER_FFCurrents = vect_ret[1]
                    No_DER_RoRCurrents = vect_ret[2]
                    No_DER_BFCCurrents = vect_ret[3]
                    kW_sim = vect_ret[4]
                    kVAr_sim = vect_ret[5]
                    reg_taps = vect_ret[6]
                    cap_steps = vect_ret[7]
                    lv_loads_layer = vect_ret[8]
                    
                    report_txt.append("Estudio base: Listo! \n") 

                    normalAmpsDic = normalAmps(DSScircuit) # Gets normal capacity for lines

                    Overvoltage_loads_df = pd.DataFrame()
                    Voltagedeviation_loads_df = pd.DataFrame()
                    Overvoltage_rest_df = pd.DataFrame()
                    Voltagedeviation_rest_df = pd.DataFrame()
                    Voltagedeviation_reg_df = pd.DataFrame()
                    Voltageunbalance_df = pd.DataFrame()
                    Thermal_loading_lines_df = pd.DataFrame()
                    Thermal_loading_tx_df = pd.DataFrame()
                    FFCurrents = pd.DataFrame()
                    RoRCurrents = pd.DataFrame()
                    BFCCurrents = pd.DataFrame()
                    SympatheticTripping_df = pd.DataFrame()
                    linelvgroups = []
                    
                    # Función para determinar el nivel inicial de DER en el sistema:
                    DERinstalled_buses_ini, DERinstalled_ini = getGDinstalled(der_ss)
                    
                    report_txt.append("El circuito posee "+str(DERinstalled_ini)+" kW de DER instalados desde el inicio \n") 

                    # Función para tomar la info de txs y mvloads
                    LoadTrafos_MVLoads = base_info_tx_and_mvloads(DSScircuit, DSSobj,
                                                                DSStext, Grafo, tx_layer, der_ss,
                                                                mv_loads_layer)
                                                                
                    
                    # Función para tomar la info de las lv_loads
                    LV_hist_df, blacklist_ini = base_info_lvloads(lv_loads_layer,
                                                                LoadTrafos_MVLoads,
                                                                DSScircuit)

                    # %% Hosting capacity analysis
                    MCSim = 1  # Total Monte Carlo Simulations
                    MV_hist_df, LV_hist_df = DER_calc(0, 0,
                                                    LoadTrafos_MVLoads,
                                                    blacklist_ini, LV_hist_df)
                    
                    # blacklist dictionary
                    blacklist_dict = {}
                    blacklist_dict[0] = blacklist_ini

                    # iterative blacklist (it updates itself with every iteration)
                    blacklist = []
                    blacklist += blacklist_ini

                    # begins the HC study
                    # While loop. It'll stop when all the MV_Groups are flagged

                    flag = False
                    # calculate initial capacity to install
                    capacity_i = 0
                    redo_sim = False
                    last_blacklisted_ov = []
                    last_blacklisted_vd = []
                    time_data = {}
                    voltage_vals = {}
                    overvoltage_vals = {}
                    final_der = -1
                    
                    report_txt.append("************************* \n") 
                    report_txt.append("Estudio de Capacidad de Alojamiento \n") 
                    report_txt.append("************************* \n")
                    
                    stop_reason = ""

                    while flag is False and capacity_i+DERinstalled_ini <= TotalCapacityMax:
                        # DER asignation
                        start_t_sim = time.time()

                        # DER asignation
                        tmp = step_calc(MV_hist_df, blacklist, 
                                         blacklist_dict, max_kVA_step,
                                         max_kVA_mvloads, lim_kVA, capacity_i)
                        der_step, capacity_i, MV_hist_df, temp_blacklist = tmp

                        len1 = len(list(set(temp_blacklist + blacklist)))
                        len2 = len(MV_hist_df.index)
                        
                        if len1 == len2 or (capacity_i + DERinstalled_ini >= TotalCapacityMax): 
                            MV_hist_df.loc[temp_blacklist, 'blacklist_info'] = np.nan
                            msg = 'Checkpoint Final - Máxima capacidad alcanzada: '
                            msg += str(DERinstalled_ini + capacity_i - der_step) +" kW. \n"
                            msg += "La razón de finalización es que no hay secundarios disponibles para alojar más DER"
                            stop_reason = "La razón de finalización es que no hay secundarios disponibles para alojar más DER"
                            print(msg)
                            report_txt.append(msg)
                            final_der = capacity_i - der_step
                            flag = True

                        else:
                            msg = 'Capacidad instalada: '
                            msg += str(capacity_i + DERinstalled_ini) + " kW \n"
                            print(msg)
                            report_txt.append(msg)

                            MV_hist_df, LV_hist_df = DER_calc(capacity_i, der_step, LoadTrafos_MVLoads,
                                                            blacklist, LV_hist_df, MV_hist_df)

                            # initialize the variables
                            DERs_LV = []
                            DERs_MV = []
                            Trafos_DERs_MV = []

                            trafo_df_f = pd.DataFrame()
                            DERs_LV, DERs_MV, Trafos_DERs_MV = DER_allocation_HHC(LV_hist_df, MV_hist_df,
                                                                                  mv_loads_layer,
                                                                                  trafo_df_f, icc_ss)
                            DERs = DERs_LV + DERs_MV

                            # Compile model for simulation - run simulation
                            # taking into consideration the new GD installed
                            DERs_Run(DSStext, DSScircuit, snapshotdate,
                                    snapshottime, firstLine, tx_modelling,
                                    substation_type, line_tx_definition,
                                    circuit_demand, Base_V, kW_sim,
                                    kVAr_sim, DERs, Trafos_DERs_MV,
                                    dir_network, reg_taps, cap_steps)

                            DSScircuit.setActiveElement('line.' + firstLine)
                            temp_powers = DSScircuit.ActiveElement.Powers
                            val = temp_powers[0] + temp_powers[2]
                            val += temp_powers[4]
                            msg = 'P_w_Sub: ' + str(val)
                            print(msg)

                            # Check HC criteria - Here, the results dataframes are
                            # updated, with all limiting criteria characteristics being monitored
                            vect_ret =  pq_voltage(DSScircuit, DSStext, dir_network,
                                                Base_V, loadslv_buses, loadsmv_buses,
                                                regs, caps, capacity_i, lv_groups,
                                                tx_groups, NoDERsPF_Vbuses,
                                                Overvoltage_loads_df, Overvoltage_rest_df,
                                                Voltagedeviation_loads_df, Voltagedeviation_rest_df,
                                                Voltagedeviation_reg_df, Voltageunbalance_df,
                                                Overvoltage_analysis, VoltageDeviation_analysis,
                                                VoltageRegulation_analysis, VoltageUnbalance, 
                                                max_v, max_lv_dev, max_mv_dev, max_v_unb, 
                                                redo_sim, last_blacklisted_ov, last_blacklisted_vd, voltage_vals, overvoltage_vals,
                                                report_txt)
                                                
                            VBuses = vect_ret[0]
                            Overvoltage_loads_df = vect_ret[1]
                            Voltagedeviation_loads_df = vect_ret[2]
                            Overvoltage_rest_df = vect_ret[3]
                            Voltagedeviation_rest_df = vect_ret[4]
                            Voltagedeviation_reg_df = vect_ret[5]
                            Voltageunbalance_df = vect_ret[6]
                            last_blacklisted_ov = vect_ret[7]
                            last_blacklisted_vd = vect_ret[8]
                            voltage_vals = vect_ret[9]
                            overvoltage_vals = vect_ret[10]
                            report_txt = vect_ret[11]

                            vect_ret = thermal_Lines_Tx(DSScircuit, DSStext, normalAmpsDic,
                                                        capacity_i, line_lv_groups,
                                                        tx_groups, Thermal_loading_lines_df,
                                                        Thermal_loading_tx_df, name_file_created,
                                                        linelvgroups, Thermal_analysis, report_txt)
                                                        
                            Thermal_loading_lines_df = vect_ret[0]
                            Thermal_loading_tx_df = vect_ret[1]
                            CurrentDF = vect_ret[2]
                            report_txt = vect_ret[3]

                            FFCurrents, BFCCurrents, report_txt = FF_BFC_Current(DSScircuit, DSStext,
                                                                    dir_network, firstLine,
                                                                    snapshottime, snapshotdate, circuit_demand,
                                                                    kW_sim, kVAr_sim, capacity_i,
                                                                    Trafos_DERs_MV, DERs,
                                                                    No_DER_FFCurrents, FFCurrents,
                                                                    No_DER_BFCCurrents, BFCCurrents,
                                                                    faulttypes, FF_analysis, BFC_analysis,
                                                                    max_increase_ff, max_increase_bfc, report_txt)

                            RoRCurrents, report_txt = ReductionReach(DSScircuit, DSStext,
                                                        dir_network, firstLine,
                                                        snapshottime, snapshotdate,
                                                        kW_sim, kVAr_sim, circuit_demand, capacity_i,
                                                        Trafos_DERs_MV, DERs,
                                                        No_DER_RoRCurrents, RoRCurrents,
                                                        faulttypes, RoR_analysis,
                                                        max_reduction, report_txt)

                            SympatheticTripping_df, report_txt = SympatheticTripping(DSStext, DSScircuit,
                                                                        dir_network, firstLine,
                                                                        snapshotdate, snapshottime,
                                                                        kW_sim, kVAr_sim, circuit_demand, 
                                                                        capacity_i, Trafos_DERs_MV, DERs,
                                                                        SympatheticTripping_analysis, 
                                                                        faulttypes, I_trip_51p, I_trip_51g, 
                                                                        SympatheticTripping_df, report_txt)

                            new_ret = flag_and_blacklist_calc(Overvoltage_loads_df, Voltagedeviation_loads_df,
                                                            Overvoltage_rest_df, Voltagedeviation_rest_df,
                                                            Voltagedeviation_reg_df, Voltageunbalance_df,
                                                            Thermal_loading_lines_df, Thermal_loading_tx_df,
                                                            FFCurrents, BFCCurrents, RoRCurrents,
                                                            SympatheticTripping_df, Overvoltage_analysis,
                                                            VoltageDeviation_analysis, VoltageRegulation_analysis,
                                                            VoltageUnbalance, Thermal_analysis,
                                                            FF_analysis, BFC_analysis, RoR_analysis,
                                                            SympatheticTripping_analysis, MV_hist_df,
                                                            capacity_i, flag, blacklist, blacklist_dict)
                            flag = new_ret[0]
                            flag_list = new_ret[1]
                            blacklist = new_ret[2]
                            blacklist_dict = new_ret[3]
                            redo_sim = new_ret[4]

                            end_t_sim = time.time()
                            time_data[capacity_i] = end_t_sim - start_t_sim

                            if flag is False:
                                if redo_sim is False:
                                    if capacity_i+DERinstalled_ini <= TotalCapacityMax:
                                        msg = 'Checkpoint - Capacidad instalada: '
                                        msg += str(capacity_i+DERinstalled_ini) + " kW \n"
                                        print(msg)
                                        report_txt.append(msg)
                                        topped_tx = list(set(temp_blacklist) - set(blacklist))
                                        blacklist_dict[capacity_i] += topped_tx
                                        blacklist = list(set(blacklist + temp_blacklist))  # update
                                        MV_hist_df.loc[topped_tx, 'blacklist_info'] = 'Suma DER instalado igual capacidad nominal Tx'
                                        # at the end:
                                        # capacity_i += der_step
                                    else:
                                        msg = 'Checkpoint Final - La máxima capacidad instalada fue de: '
                                        msg += str(DERinstalled_ini+capacity_i-der_step) +" kW. \n"
                                        msg += "La razón de finalización fue que el nivel de DER en el circuito excedió la cantidad máxima especificada"
                                        stop_reason = "La razón de finalización fue que el nivel de DER en el circuito excedió la cantidad máxima especificada"
                                        
                                        # Modifica el MV_hist
                                        sum_stop_reason = "Máxima capacidad alcanzada en el circuito"
                                        mask = MV_hist_df['blacklist_info'].apply(lambda x: not isinstance(x, str))
                                        MV_hist_df.loc[mask, "blacklist_info"] = sum_stop_reason
                                        
                                        print(msg)
                                        report_txt.append(msg)
                                        final_der = capacity_i - der_step
                                        # at the end:
                                        # capacity_i += der_step

                                else:
                                    msg = 'Checkpoint - Capacidad instalada: '
                                    msg += str(capacity_i+DERinstalled_ini) + ' kW - existen problemas de tensión '
                                    msg += 'o térmicos. El análisis se repetirá fijando la capacidad previa asignada en los '
                                    msg += 'secundarios con problemas y reasignando la capacidad de DER para la iteración '
                                    msg += 'en los secundarios sin problemas \n'
                                    print(msg)
                                    report_txt.append(msg)
                                    MV_hist_df = MV_hist_df.drop(columns=[capacity_i])
                                    for group in LV_hist_df:
                                        LV_hist_df[group] = LV_hist_df[group].drop(columns=[capacity_i])
                                    # comes back to the previous analysed level
                                    capacity_i = capacity_i - der_step

                            else:
                                msg = 'Checkpoint Final -  Máxima capacidad alcanzada:'
                                msg += str(capacity_i + DERinstalled_ini - der_step) + " kW \n"
                                print(msg)
                                report_txt.append(msg)
                                flag_list_str = ''
                                for crit in range(len(flag_list)):
                                    if len(flag_list) == 1:
                                        flag_list_str += flag_list[crit]
                                    else:
                                        if crit < (len(flag_list)-2):
                                            flag_list_str += flag_list[crit] + ', '
                                        elif crit == (len(flag_list)-2):
                                            flag_list_str += flag_list[crit] + ' y '
                                        else:
                                            flag_list_str += flag_list[crit]

                                msg = 'Los criterios ' + flag_list_str
                                msg += ' pararon la simulación \n '
                                
                                stop_reason = "Los criterios " + flag_list_str +' pararon la simulación \n '
                                
                                # Modifica el MV_hist
                                sum_stop_reason = flag_list_str
                                mask = MV_hist_df['blacklist_info'].apply(lambda x: not isinstance(x, str))
                                MV_hist_df.loc[mask, "blacklist_info"] = "Problema MT - " + sum_stop_reason
                                        
                                print(msg)
                                report_txt.append(msg)
                                final_der = capacity_i - der_step

                    # Reports how many minutes the simulation took
                    end = time.time()
                    whole_sim_time = end - start
                    time_data['total'] = whole_sim_time
                    msg = 'Tiempo de simulación: '
                    msg += str(round(whole_sim_time/60, 2))
                    msg += ' min.'
                    print(msg)
                    
                    # Crea carpeta para resultados en caso de que no exista
                    res_ss_dir = dir_general+"\\HC_RES_SS"
                    res_ss_crit_dir = res_ss_dir+"\\Resultados_Criterios"
                    
                    if not os.path.exists(res_ss_dir):
                        os.makedirs(res_ss_dir)
                    
                    # Crea carpeta para resultados por criterios
                    if not os.path.exists(res_ss_crit_dir):
                        os.makedirs(res_ss_crit_dir)
                        
                    # Modify the MV_hist 
                    print(MV_hist_df)
                    if final_der != 0:
                        # Get the column names that are numbers and add the initial DER installed
                        MV_hist_df.columns = [(int(col) + DERinstalled_ini) if str(col).isnumeric() else col for col in MV_hist_df.columns]
                        final_der = int(final_der + DERinstalled_ini) # Incluye el dato inicial
                        tx_idxs = [x for x in list(MV_hist_df.index) if "n_MV" not in x]
                        MV_hist_df.loc[tx_idxs,final_der] = MV_hist_df[final_der] + (MV_hist_df["Rating"] - MV_hist_df["Av_Rating"])
                        imp_col_names = ["DSSNAME", "LV_GROUP", "Rating", "blacklist_info", final_der]
                      
                        MV_hist_df[imp_col_names].to_excel(res_ss_dir+'\\Resultados_Secundarios.xlsx', index=False)
                    
                    

                    for elem in MV_hist_df.index:
                        try:
                            idx_tx = tx_layer.loc[tx_layer['DSSNAME'] == elem].index.values[0]
                            tx_layer.loc[idx_tx,"HC_RES_SS"] = MV_hist_df.loc[elem, final_der]
                            
                        except Exception:
                            pass
                    
                    x = data_grouping(Grafo, MV_hist_df, fixed_distance, final_der,
                                      lines_mv_oh_layer_original,
                                      lines_mv_ug_layer_original, lim_kVA)
                    
                    lines_mv_oh_layer_original = x[0]
                    lines_mv_ug_layer_original = x[1]
                    name_col = "HC_RES_SS"
                    
                    # Caso en que hayan habido errores
                    if lines_mv_oh_layer_original.empty:
                        return None
                    
                    n_ranges = []  # Declare the ranges variable outside the if statements
                    
                    if layer_mt_aer != [] and layer_mt_aer != 0:
                        self.save_dataframe(lines_mv_oh_layer_original,
                                            layer_mv_oh, name_col)
                        n_ranges = self.categ_layer(lines_mv_oh_layer_original,
                                         layer_mv_oh, name_col)
                    if layer_mt_sub != [] and layer_mt_sub != 0:
                        self.save_dataframe(lines_mv_ug_layer_original,
                                            layer_mv_ug, name_col)
                        n_ranges2 = self.categ_layer(lines_mv_ug_layer_original,
                                            layer_mv_ug, name_col, n_ranges)            
                    
                    MV_hist_df.rename({final_der: name_col}, axis=1, inplace=True) 
                    self.save_dataframe(MV_hist_df, layer_trafos, name_col) # Guarda el resultado en capa
                        
                    msg  = "Simulación finalizada exitosamente \n"
                    msg += "La capacidad final alcanzada fue de "+ str(final_der)+" kW \n "
                    msg += stop_reason + " \n"
                    msg += 'Tiempo de simulación: '
                    msg += str(round(whole_sim_time/60, 2))
                    msg += ' min.'
                    msg += "\n Los resultados se guardaron en el siguiente "
                    msg += "directorio: " + res_ss_dir
                    title = "Final"
                    QMessageBox.information(None, title, msg)
                    
                    # Guarda registro de resultados
                    
                    with open(res_ss_dir+'\\seguimiento_resultados.txt', 'w') as f:
                        f.writelines("%s\n" % line for line in report_txt)
                    
                    with open(res_ss_dir+'\\HC_DER_LV.dss', 'w') as f:
                        f.writelines("%s\n" % line for line in DERs_LV)
                    
                    with open(res_ss_dir+'\\HC_DER_MV.dss', 'w') as f:
                        f.writelines("%s\n" % line for line in DERs_MV)
                    
                    #Guarda los resultados de la evaluación de cada criterio
                    
                    # Tensión:
                    
                    
                    update_final_dataframe(Overvoltage_loads_df, DERinstalled_ini, final_der).to_excel(res_ss_crit_dir+'\\Resultados-Sobretensión_Cargas.xlsx', index=False)
                    update_final_dataframe(Overvoltage_rest_df, DERinstalled_ini, final_der).to_excel(res_ss_crit_dir+'\\Resultados-Sobretensión_Lineas_Trafos.xlsx', index=False)
                    update_final_dataframe(Voltagedeviation_loads_df, DERinstalled_ini, final_der).to_excel(res_ss_crit_dir+'\\Resultados-Desviacion_Tensión_Cargas.xlsx', index=False)
                    update_final_dataframe(Voltagedeviation_rest_df, DERinstalled_ini, final_der).to_excel(res_ss_crit_dir+'\\Resultados-Desviacion_Tensión_Lineas_Trafos.xlsx', index=False)
                    update_final_dataframe(Voltagedeviation_reg_df, DERinstalled_ini, final_der).to_excel(res_ss_crit_dir+'\\Resultados-Regulación_Tensión.xlsx', index=False)
                    update_final_dataframe(Voltageunbalance_df, DERinstalled_ini, final_der).to_excel(res_ss_crit_dir+'\\Resultados-Desbalance_Tensión.xlsx', index=False)                                            
                    
                    # Térmicos
                    update_final_dataframe(Thermal_loading_lines_df, DERinstalled_ini, final_der).to_excel(res_ss_crit_dir+'\\Resultados-Cargabilidad_Líneas.xlsx', index=False)  
                    update_final_dataframe(Thermal_loading_tx_df, DERinstalled_ini, final_der).to_excel(res_ss_crit_dir+'\\Resultados-Cargabilidad_Trafos.xlsx', index=False)  
                    
                    # Protecciones
                    update_final_dataframe(FFCurrents, DERinstalled_ini, final_der).to_excel(res_ss_crit_dir+'\\Resultados-Aumento_Falla.xlsx', index=False)
                    update_final_dataframe(BFCCurrents, DERinstalled_ini, final_der).to_excel(res_ss_crit_dir+'\\Resultados-Coordinacion_FusibleRecloser.xlsx', index=False)
                    update_final_dataframe(RoRCurrents, DERinstalled_ini, final_der).to_excel(res_ss_crit_dir+'\\Resultados-Reducción_Alcance.xlsx', index=False)
                    update_final_dataframe(SympatheticTripping_df, DERinstalled_ini, final_der).to_excel(res_ss_crit_dir+'\\Resultados-Disparo_Indebido.xlsx', index=False)

        
        except Exception:
            title = "Final"
            msg = "Simulación finalizada con errores \n"
            self.print_error()
            QMessageBox.critical(None, title, msg)
            
